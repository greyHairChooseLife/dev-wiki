

> [!nt] 입소식
>
> 여러분들이 **성장**을 많이 언급하셨다. 성장의 지표를 정해보는것도 좋겠다는 생각을 했다. 화면으로
> 만나본 의장님은 _기본기/꾸준한_학습/경험의_축적/팀워크(함께 할 수 있는사람)_를 강조하셨다. 그리고
> 여기 커리큘럼 좋은 것이니 나중 일을 생각 말고 '오늘, 이번주'에 집중하는게 좋다고도 하셨다.


> [!nt] Tip
>
> - 원한다면 CSAPP 관련 주제로 발표 영상을 만들 수 있다. 아마 유투브에 업로드도 시켜주시는 것 같다.
> - 잘하는 사람들의 방식을 나도 해보자. 정글 과정이 끝나도 이어나갈 수 있는 나의 방식을 찾자.
>   - 공부도, 소통도



## TODO

> [!td]
>
> - [ ] 나의 성장은 무엇인지 정의하고 구체적 목표 세우기
>
>   - [ ] 하루의 시작에 당일 수행할 것 체크리스트를 작성하고 그에 따라 움직이자
> 
> > - 나의 성장은 무엇인가? 내가 했던 말과 생각 
> > 
> >   _"구체적이며 신뢰할 수있는 학습 로드맵과 멘토, 그리고 비슷한 목표를 가진 동료를 얻기위해 지원합니다."_
> > 
> > 


> [!td]
> 
> 팀별 면담 후 지호님과 말씀을 나누면서 알고리즘 주간에 대한 나의 생각이 많이 바뀌었다.
> 
>   - 주어진 문제의 정답을 전부 맞추는 것 자체가 중요한게 아니다.
>   - 모든 문제를 풀어보는 기회를 가지자. 그러기 위해서 아쉬워도 시간제한을 철저히 두자.
>   - 소요시간에 따라 점진적으로 힌트를 조금씩 얻어가면서 시도해보자.
>   - 학습할 키워드도 있다.
>   - 알고리즘 주간에 (제공받은 책들) 'Do it!' 뿐만 아니라 CSAPP, 운영체제 책도 일부 소화해야 한다.
>   - hong 강의도 최소한의 시간 배분을 해야한다.
>
> - [ ] '정글' 전과정에 걸쳐 책읽기 목표를 정하자
>   - 어렵다면 일단 알고리즘 주간에 마칠 중간 목표라도 정하자
>   - [ ] Do it!: 파트n
>   - [ ] CSAPP:
>   - [ ] 운영체제:
>
> - [ ] 책읽기 목표를 위하여 '언제/얼만큼씩 시간을 투입'할지 계획하고 '캘린더에 반복일정 생성'하자.
>   - [ ] Do it!: n요일 / nn:nn ~ nn:nn
>   - [ ] CSAPP:
>   - [ ] 운영체제:
>
> - [ ] 주차별 키워드 등 주차별 노트 생성시 기본적으로 세팅하자.
>   - [ ] 한 문제당 총 시간: n분
>   - [ ] 점진적으로 힌트를 얻어갈 기점: n분
>
> - [ ] 알고리즘 문제 하나당 얼만큼의 시간을 투입할지 계획하자.
>   - [ ] 한 문제당 총 시간: n분
>   - [ ] 점진적으로 힌트를 얻어갈 기점: n분
>
> - [ ] hong 강의를 위한 시간을 배분하자.
>   - [ ] 언제/얼만큼씩
>     - [x] 파이썬 기초: 2025-09-12
>     - [ ] 파이썬 자료구조: 
>     - [ ] 파이썬 알고리즘: 
>     - [c] C언어: 
>   - [ ] 캘린더에 입력



> [!td]
>
> - [ ] 콤파스의 챕터 1~3에 해당하는 컨텐츠를 잘 읽어보고 분류해 활용하자. 여기 노트에 잘 기록하자.


### DONE

> [!tdd]
>
> - [x] 알고리즘 주간을 위한 노트 구조 재편
>   - [x] 키워드 학습 포함하기


> [!tdd]
> ~ 2025-09-25
>
> - 대한상공회의소 KDT 관련 안내에 부쳐
>   - 박수정 담당자님 oojoo08@korcham.net 02-6050-3903
>   - [x] 고용보험임의가입 알아보기
>     - [x] 휴업중에도 가능한가? 
>       - 휴업중에 가능한지는 모르겠으나 복수의 사업자에 대하여 복수 가입은 불가함
>     - [x] 하는것이 나에게 이득일지 확인
>       - 이득
>     - [c] 대한상공회의소에서 메일로 묻기
>       - [x] 요청해준 것은 복수의 사업자에 대하여 해야하는가?
>         - 하나만 해도 됨
>       - [c] 치과 교정 관련 괜찮은지


## 대화와 친절


> [!lg] Log 2025-09-09, 지호님
> "함수를 만들어 사용할 때 글로벌 변수에 의존하는 것은 나쁜 습관이다."


> [!td] 작은 친절에 보답하기
>
> - [ ] 2025-09-10 / 민정님 / 랜덤런치 때 휴대폰을 두고온 나에게 밥값/커피값을 빌려주셨다. 
> - [ ] 2025-09-12 / 창민님 / 내가 자리에 없을 때 물티슈 뚜껑 닫아주셨다. 마를까봐.
>   - 그 얘길 농담처럼 하시면서 슬쩍 인사를 해주셨는데, 별거 아닐수도 있지만 먼저 선의와 호의를 베푸
>     는 것은 분명 감사할 일이다.


> [!lg] Log 2025-09-17 (수) 10:51
>
> 아침부터 2층에 와 있다가 미화 담당 어머님 한 분과 인사 할 수 있었다. 마침 궁금했던것을 이야기
> 드렸다. 이곳의 직원분들이 대체로 그렇지만, 어떻게 이렇게 다들 밝으시지?
>
> 인사를 하면 너나할것 없이 모두 환한 표정으로 받아주신다. 물론 좋은 일이지만, 나도 평소 꽤나
> 긍정적으로 지내는 사람이지만, 낯설 정도이다. 아, 이걸 어제 현수코치님께도 여쭤볼껄!
>
> 하여튼 여사님 말씀은 반대로라는 것이었다. 여사님들 개개인의 특성도 있지만, 학생들이 친절하고, 밝고
> 또 자식같은 나이대의 애들이 열심히 지내는 모습에 더 잘해주고싶은 마음도 있다하셨다. 짧은 이야기를
> 하는 동안에도 참 밝으셨고, 그 사이에도 나에게 여러가지 칭찬과 덕담을 여러번이나 주셨다. 감사했다.
>
> 다가오는 연휴에 캐나다 여행을 다녀오신단다. 자연경관이 멋진 곳에서 직접 차도 운전하고 트래킹도
> 하신다는데, 아주 좋으시겠다. 거기서 우연히 우리 누나랑 아루형을 만나면 더 좋겠다.



> [!lg] Log 2025-09-20
>
> 동현님
>
> 같은 팀이 되고서 첫 코어타임이 끝난 뒤 먼저 말씀을 걸어주셨다. 괜찮았느냐고, 혹시 불편하거나
> 바라는 개선점같은 마음에만 있는 이야기는 없느냐고 말이다. 나는 그런 말을 들어본 적이 없는것만
> 같아서 엄청 낯설었다. '이분은 나를 어느정도 살펴보기도 전에 내 마음을 먼저 물어봐 주시는구나'하고
> 생각했다. 타인에게 그렇게 다가가는 것은 쉬운일이 아니다. 내면의 강함이 필요한 일이고, 알게 모르게
> 우리 마음의 에너지를 소모하는 일이다. 고마웠다.
>
> 우리는 그날 자정무렵 코어타임을 끝냈는데, 새벽 네시쯤인가? 그때까지 떠들었다.



> [!lg] Log 2025-09-25
>
> 창민님 동현님
>
> 창민님이 나타나셔서 동현님이랑 나를 칭찬해주셨다. 나를 굉장히 열려있는 사람, 편안하게 다가갈 수
> 있게 만들어주는 사람이라고 하셨다.
>
> 동현님에 대해서는 대화를 잘한다고 하셨다. 함께 있는 사람들이 편안하게 하고싶은 이야길 나눌 수 있게
> 만들어 준다고 말이다.
>
> 난 창민님이 경주사람인 것이 어울린다고 생각했다. 나는 여기 정글에서 나눈 대화중엔 창민님이랑
> 해본게 제일 재밌었던 것 같다.



> [!lg] Log 2025-09-26
>
> 앗... 뜻밖에 고백을 받았다. 사랑 고백은 아니고.
>
> 다른반 분이다. 언제였지 기억도 안나게 한번 인사를 나눴던 분이신데, 얼마 뒤 아침을 먹으려고 식당에
> 갔다가 혼자 계셔서 슥 옆에 가 앉았었다. 우리는 실력이 비교적 부족한 상황의 어려움에 대해 공감하고
> 자조하는 코드로 위로인지 응원인지 하여튼 재미있게 떠들었었다.
>
> 저녁에 2층에서 공부하고 있는데, 갑자기 나타나시더니 맛있는 간식을 한움큼 주시면서 인사를 해주셨다.
> 잠시 이야기 하고싶으신 눈치라 로비로 나갔는데, 칭찬을 엄청 해 주셨다. 지난주에 우리 조원들과
> 코어타임 재미있고 열정적으로 보내던 것 너무 부럽다고, 식당에서 밥먹는 모습도 보면 언제나 다 같이
> 즐거워 보인다고 이야기 해 주셨다.
> 
> 이럴수가~~ 난 그냥 내가 잘 지내고 같이 있는 사람들도 가급적 잘 지내기를 바라는 사소한 마음이라고
> 생각했는데, 이분께는 그게 꽤나 커 보였나보다. 같이 면접도 봤었고 인사도 많이했지만 정작 이야기는
> 제대로 나눠보지 못한 다른 반 분 이야기도 전해주셨다.
>
> 나는 오히려 이렇게 다가와서 칭찬해주시고 자기 마음도 표현해 주시는게 더 멋지다고 생각했다. 
>
> 나도 뭔가 하고싶은데... 사랑을 전파하고싶은데.. 생각해보면 나는 이곳에 들어와서 지금까지 어쩔 수
> 없는 상황을 잘 수용하고, 침착하려하고, 좋은 것이나 좋은 사람을 보면 그냥 좋아할 뿐 옆에있는
> 사람들을 위해서 어떤 뚜렷한 노력을 하고있는건 아닌것같다. 어쩐지 주차별 회고를 해보면 쓸 말이
> 없더랬다. 나는 사람들에게 잘 하고 있는 것일까?




## 협업을 위한 git

> [!td]
>
> - [ ] gh dash 설치하고 활용하기: PR 및 Issue를 쉽게 보고 응답가능

### PR을 fetch해서 로컬에서 변경내역 확인하기


```bash
gh pr list
gh pr checkout <name-what-I-want>
# in DiffviewFileHistory --range=origin/dev..HEAD
```


> [!lg] Log 2025-09-03
>
> **실행 계획:**
> 1. `gh pr list`로 PR 번호를 확인한다.
> 2. PR 번호를 사용해 PR의 head를 fetch한다.
> 3. 로컬 브랜치로 체크아웃한다.
> 4. 원하는 브랜치와 비교한다.
>
> **예시:**
> PR 번호가 123이고, 내 로컬 브랜치가 `main`이라면:
>
> ```bash
> git fetch origin pull/123/head:pr-123
> git checkout pr-123
> git diff main...pr-123
> ```



### 내가 작업한 브랜치 PR 날리기


  ```bash
  # 현재 브랜치를 원격 저장소로 푸시
  git push origin HEAD

  # GitHub CLI로 PR 생성
  gh pr create --base <target branch>
  ```

  - 이후에 추가적이 변경이 생기면 그냥 commit 후 다시 push하면 자동으로 PR에 반영된다. PR은 remote에
    존재하는 두 브랜치를 비교하는거기 때문에

  - feature 브랜치를 dev 기준으로 rebase하는 체크리스트

    ```bash
    # 1. 원격 dev 브랜치 최신화
    git fetch origin dev

    # 2. 로컬 dev 브랜치 최신화
    git checkout dev
    git merge origin/dev

    # 3. 작업 브랜치(feature)로 이동
    git checkout <feature-branch>

    # 4. dev 브랜치 기준으로 rebase
    git rebase dev

    # 5. (충돌 발생 시)
    - 충돌 파일 수정
    - git add <수정한 파일>
    - git rebase --continue

    # 6. rebase 완료 후 원격 브랜치 강제 푸시, rebase는 해당 브랜치의 부모 커밋 해시를 바꾼다.
    git push origin <feature-branch> --force

    # 7. (rebase되어 기존 맥락을 잃어버리면 헷갈릴 수 있으니 필요시 알려준다.)
    (필요시) PR에서 rebase로 인해 변경된 내용 코멘트 남기기

    # 7. (merged 이후 브랜치 삭제하기)
    (필요시) git push origin --delete 브랜치이름
    ```






## 학습


### TODO

_- 주차별 키워드_
_- 아래에 자료구조/알고리즘에 각각 분류하여 노트한다._


#### 3주차

> [!td]
>
> - [ ] BFS / DFS
>   - [x] 개념 알기
>   - [ ] 코드 구현
>   - [x] 기본 문제 풀기
> 
> - [ ] 위상 정렬
>   - [x] 개념 알기
>   - [ ] 코드 구현
>   - [x] 기본 문제 풀기
> 
> - [ ] B-Tree (Optional)
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기
> 
> - [ ] 트라이(Trie)
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기
> 
> - [ ] 다익스트라, 플로이드 와샬
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기
> 
> - [ ] 최소 신장 트리
>   - [x] 개념 알기
>   - [ ] 코드 구현
>   - [x] 기본 문제 풀기




#### 4주차

> [!td]
>
> - [ ] 다이나믹 프로그래밍
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기
>
> - [ ] 그리디 알고리즘
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기
>
> - [ ] LCS (Longest Common Subsequence)
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기
>
> - [ ] Knapsack Problem
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기
>
> - [ ] Linked List
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기
>
> - [ ] 포인터(pointer), & 연산자와 * 연산자
>   - [ ] 개념 알기
>   - [ ] 코드 구현
>   - [ ] 기본 문제 풀기


### CSAPP

[Chapter.1 컴퓨터 시스템로의 여행](Chapter.1_컴퓨터_시스템로의_여행)

[Chapter.2 정보의 표현과 처리](Chapter.2_정보의_표현과_처리)

[Chapter.3 프로그램의 기계수준 표현](Chapter.3_프로그램의_기계수준_표현)



### C언어


> [!td]
>
> 스터디 학습 진행
>
> - [c] 10강까지 듣고 2025-09-14 (일) 20:00
> - [x] 9강까지 듣고 2025-09-14 (일) 20:00
> - [ ] 17강 까지 듣고 2025-09-28 (일)

                    

> [!rf]
> - 유투브 - 널널한 개발자
> [인프런-독하게 시작하는 c프로그래밍](https://www.inflearn.com/course/%EB%8F%85%ED%95%98%EA%B2%8C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-c%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)#### DONE
> - 이른바 '곰' 책이라 불리는 OS 책. 무료 해설 강의가 유투브에 풀려있다.


#### DONE

> [!tdd]
> - [x] [python debug setup](https://www.youtube.com/watch?v=tfC1i32eW3A)



### 자료구조 & 알고리즘

```
컴퓨터 과학
├─ 자료구조 (Data Structure)
│   ├─ Stack
│   ├─ Queue
│   ├─ Heap
│   ├─ Tree
│   └─ Graph
│
├─ 알고리즘 패러다임 (Algorithm Paradigm)
│   ├─ Divide & Conquer
│   ├─ Greedy
│   ├─ Dynamic Programming
│   ├─ Backtracking
│   ├─ Branch & Bound
│   └─ Brute Force
│
└─ 알고리즘 (Algorithm)
    ├─ Stack 활용
    │   ├─ DFS (패러다임: Brute Force, Backtracking)
    │   ├─ 재귀호출 (패러다임: Divide & Conquer, DP, Backtracking)
    │   │   ├─ Quick Sort (Divide & Conquer)
    │   │   ├─ Merge Sort (Divide & Conquer)
    │   │   ├─ Fibonacci (DP, 재귀)
    │   │   └─ N-Queen (Backtracking)
    │   └─ 기타
    │
    ├─ Queue 활용
    │   ├─ BFS (패러다임: Brute Force)
    │   ├─ 우선순위 Queue (Heap 기반)
    │   │   ├─ Dijkstra (Greedy)
    │   │   └─ Prim (Greedy)
    │   └─ 기타
    │
    ├─ Heap 활용
    │   └─ Heap Sort (Divide & Conquer)
    │
    ├─ Tree/Graph 활용
    │   ├─ Kruskal (Greedy, Union-Find)
    │   ├─ Bellman-Ford (DP)
    │   └─ 기타
    │
    └─ 기타 알고리즘
```

#### 자료구조

- [ ] 그래프

- 그래프(Graph)

  - 그래프의 종류: 방향/무방향, 가중치/비가중치, 연결/비연결
  - 표현 방법: 인접 행렬, 인접 리스트
  - 그래프의 용어: 정점(Vertex), 간선(Edge), 차수(Degree), 경로(Path), 사이클(Cycle)


#### 알고리즘

##### 1주차 

##### 정렬

**정렬의 분류**

  - 안정 vs 불안정

    값이 정렬된 후에도 가능한 정렬 이전의 index를 유지(크기가 동일한 것 사이에)


  - 내부 vs 외부정렬
    
    정렬 하려는 배열만 가지고도 정렬할 수 있는 경우
    (어떤 정렬은 임시로 어디에 넣어둬야한다.)


---

**단순정렬 `O(N^2)`**
  
  - 버블 정렬: 바로 옆에랑 비교해서 자리바꾸기를 연속적으로
    - 개선 1: 마지막 pass 지점 기록해서 안해도 될 일은 안하기
    - 개선 2: 우>>좌, 좌<<우 반복하는 shaker 정렬

    - 두개 동시에 쓰면 될듯?


  - 선택 정렬: 아직 정렬 안된 애들중에 젤 작은거 찾아서 쌓아가기
    - 이런식이면 이제 순서가 바뀌는 불안정 정렬
   

  - 삽입 정렬:

    이미 정렬 된 애들중에서 비교해가며 자리를 찾는다. 한번 자리 찾으면 이후로는 비교 안해도
    되니까 어느정도 정렬이 되어있을수록 빠를 가능성이 높음

    이론상 시간복잡도 `O(N^2)`이지만 보통 효율 좋음



  - > [!nt] 선택정렬 vs 삽입정렬
    >
    > 이놈들은 언뜻 보기에는 똑같아 보인다. 다른 점은 '이번에 정렬할 원소'의 위치를 얻기 위해
    > 비교가 어디에서 이루어지는가이다.
    > 
    > 두 정렬 방법 모두 좌측(또는 한 쪽)에 정렬된 애들을 쌓아가는 방식인데,
    > 
    >   **선택정렬은 나머지를 비교**하여 가장 작은 애를 찾아야한다. 즉, 아직 정렬되지 않은 우측
    >   애들을 전부다 비교해 봐야한다.
    > 
    >   반면, **삽입정렬은 이미 정렬 된 애들 사이에서 비교**한다.
    > 
    > 이렇게 되면 '선택정렬'은 아직 정렬되지 않은애들의 개수만큼 반드시 비교해야하고,
    > '삽입정렬'은 가장 크거나 작은 쪽부터 비교해 들어가다가 자리를 찾으면 그 이상은 비교하지
    > 않아도 된다.
    > 
    > 그래서 이미 어느정도 정렬이 되어있는 상태라면 매우 좋은 효율을 보이고, 최악의 경우라도
    > 선택정렬보다 뒤떨어지진 않는다.






- 링크드 리스트

  - 정의: 값과 다음(및 이전) 노드 주소를 가진 노드들이 포인터로 연결된 선형 자료구조(단일/이중).

  - 핵심 연산·시간복잡도:
    - 탐색: O(n)
    - 머리 삽입: O(1)
    - 임의 위치에서 삭제/삽입: 노드 참조가 주어지면 O(1), 그렇지 않으면 탐색 O(n)
    - 꼬리 삽입: 꼬리 포인터 있으면 O(1), 없으면 O(n)

  - 사용처: 크기가 자주 변하고 중간 삽입/삭제가 잦을 때.




- 해시 테이블

  - "키-값 쌍"을 저장하는 자료구조
  - 해시 함수는 "키"를 받아 "해시값(인덱스)"을 만듦
  - 키가 반드시 있어야함
    - 단, "값"을 "키"로 사용할 수도 있음 (예: set 자료구조는 값 자체를 키로 사용)

  - 해시값이 같을 수 있음(충돌 발생) → 서로 다른 키가 같은 해시값을 가질 수 있음
    - 체이닝(Chaining): 같은 인덱스에 여러 (키, 값) 쌍을 리스트 등으로 저장
    - 오픈 어드레싱(Open Addressing): 빈 칸을 찾아 (키, 값) 쌍을 저장. 그냥 옆으로 이동할수도
      있고, 대응하는 2차 해시함수가 또 있을수도 있다.

  - 저장/검색/삭제 시 해시값으로 찾아보고 이후 "키"를 직접 비교해서 원하는 데이터를 찾음
    - 왜냐면 "키"가 달라도 해시값은 같을 수 있으니까
    - 해시값만으로는 원본 키를 알 수 없음 → 키를 반드시 같이 저장해야 함

  - 동일한 키로 값을 넣으면 기존 값이 덮어써짐  
  - 예시) 파이썬 dict, 자바 HashMap










##### 3주차


##### union & find(서로소 집합 찾기)


- cycle 찾기에 사용된다.
- 내 부모 노드의 부모 노드를 찾는다. 재귀적으로!
  - 그러다보면 결국 제일 끝에 조상님을 찾게 된다.
  - 이 원리를 활용하면 한 조상 아래 모인 노드집합을 확인할 수 있다.

- **union find 연산** [reference](https://www.youtube.com/watch?v=DI0e7XcNaTY)

  > **전제: "root는 부모로 자기자신을 갖는다."**
  > 
  > ```py
  > # 초기화 예시: parent = [i for i in range(N+1)]
  > # 0번째는 버리기 위해 위 처럼 
  > 
  > parent = [
  >   1,
  >   2,
  >   3,
  >   ...
  > ]
  > ```
  > 
  > 
  > - `find(x)`: 노드가 속한 집한의 root를 찾는다.
  >
  >   ```py
  >   # node가 root와 같은지 확인한다.
  >   def find(x):
  >       if parent[x] != x:                # 자기자신이 자신의 부모노드가 될 때까지(즉, root노드의 조건) 재귀적으로 시도한다.
  >          return find(parent[x])
  >       return parent[x]
  >   ```
  >   
  >   - **경로 압축 신공: union 연산 및 find 연산을 시간복잡도 거의 O(N)으로 만들어준다.**
  >     ```py
  >     # node가 root와 같은지 확인한다.
  >     def find(x):
  >         if parent[x] != x:
  >            parent[x]  = find(parent[x])   # 여기서 대입 연산자를 통해 계속 부모의 부모를 찾아 대입한다.(재귀)
  >         return parent[x]                  # 최종적으로 return 되는 것은 root 노드로 부모가 대입된 최종본이다.
  >     ```
  >   
  > 
  > - `union(x, y)`: 두 노드가 속한 두 집합을 하나로 합침
  >
  >   ```py
  >   # 두 노드의 root가 다르다면 root를 일치시킨다.
  >   def union(x, y):
  >       rootX = find(x)
  >       rootY = find(y)
  >   
  >       if rootX != rootY:
  >          parent[rootY] = rootX  # 어느쪽으로 해도 상관없다. 다만 조건을 주고 이를 활용할 수 있다.(정렬 등)
  >   ```
  >   
  > 
  > - `same(x, y)`: 두 노드가 동일한 집합에 속하는지(연결요소인지) 확인(`find(x) == find(y)`)
  >
  >   ```py
  >   # 두 노드의 root가 동일한지 확인한다.
  >   def same(x, y):
  >       return find(x) == find(y)
  >   ```



##### BFS (너비 우선 탐색)

- 탐색 원리 및 구현 방법 (큐 사용)
- 시간/공간 복잡도
- 최단 경로 탐색에서의 활용
- 예제: 미로 탐색, 그래프 레벨 탐색

- [백준 1926번: 그림](https://www.acmicpc.net/problem/1926)  


> [!nt] DFS vs BFS 구현 차이
>
> - DFS: Stack에서 꺼낼 때 visited = True
> - BFS: Queue에   넣을 때 visited = True


##### DFS (깊이 우선 탐색)

- 탐색 원리 및 구현 방법 (스택/재귀)
- 시간/공간 복잡도
- 사이클 탐지, 연결 요소 찾기
- 예제: 그래프 경로 찾기, 백트래킹

- [백준 2606번: 바이러스](https://www.acmicpc.net/problem/2606)  


> [!nt] DFS vs BFS 구현 차이
>
> - DFS: Stack에서 꺼낼 때 visited = True
> - BFS: Queue에   넣을 때 visited = True


##### 위상 정렬(Topological Sort)


- 위상 정렬의 정의와 조건 (DAG)

  - 위계(순서)를 잃지 않으면서 정렬하는 방법을 구하는 것

- 구현 방법: Kahn’s Algorithm, DFS 기반

  1. 진입차수가 0인 것들부터 queue에 담아주고,
  2. 담아준 nodes를 제거하여 진입차수가 0이 된 것을 확인한다.


- 활용 예시: 작업 순서 결정, 의존성 해석


- [백준 2252번: 줄 세우기](https://www.acmicpc.net/problem/2252)  



##### B-Tree (Optional)


- B-Tree의 구조와 특징

  - B-Tree는 이진탐색트리(BTS)의 일반화한 버전이다.


  - key들은 노드 안에서 항상 정렬된 값을 가짐
  - 각 key들의 왼쪽 자식들은 항상 key보다 작은 값을, 오른쪽은 큰 값을 가집

  - **B-Tree**는 균형 잡힌 트리 자료구조의 한 종류(사이클이 없는 연결 그래프)
  - 한 노드에 여러 개의 키(값)와 자식 포인터(방향있는 간선)를 가질 수 있음
  - 트리의 높이가 낮아져서, 데이터 검색, 삽입, 삭제가 빠름
  - 균형 트리: 모든 리프 노드는 같은 레벨
  - 주로 디스크 기반 저장장치(데이터베이스, 파일 시스템)에서 사용

  - **Tree**는 그래프의 한 종류
  - **B-Tree**는 트리 자료구조의 한 종류로, 그래프의 특수한 형태

    ```자료구조
    - Graph
      - Tree
        - B-tree
    ```


- 삽입/삭제/탐색 알고리즘
- 활용 분야: 데이터베이스, 파일 시스템


##### 트라이(Trie)

- 트라이의 구조와 원리
- 삽입/탐색/삭제 연산
- 문자열 검색, 자동완성, 접두사 검색
- [백준 14425번: 문자열 집합](https://www.acmicpc.net/problem/14425)  


##### 다익스트라(Dijkstra), 플로이드-와샬(Floyd-Warshall)

- 다익스트라: 단일 출발점 최단 경로, 우선순위 큐 활용
- 플로이드-와샬: 모든 쌍 최단 경로, DP 활용
- 구현 방법 및 시간 복잡도
- 음수 가중치 처리 여부
- [백준 1753번: 최단경로](https://www.acmicpc.net/problem/1753) (다익스트라)  
- [백준 11403번: 경로 찾기](https://www.acmicpc.net/problem/11403) (플로이드-와샬)


##### 최소 신장 트리(MST, Minimum Spanning Tree)

- 가중치 총합이 가장 낮은 Spanning Tree

  > [!nt] Spanning Tree
  >
  > - no cycle _(tree니까 당연히)_
  > - connects all nodes _(즉 연결요소가 하나인 것)_
 
  > [!nt]
  >
  > - cycle
  >   - 자기 자신에게 돌아오는 것
  > 
  > - tree는 graph의 일종으로, cycle이 없는 것을 뜻 함



- Kruskal's 알고리즘이 가장 유명하다.

  1. edge를 없다고 가정한다.
  2. weight을 기준으로 priority queue에 넣는다.
  3. `while queue:`
     - dequeue
     - cycle detection(by union find)
       - not fount ==> connect 
       - found     ==> skip





##### 4주차

##### Dinamic Programming (DP)


- **하향식(Top-Down, 메모이제이션)**

  - 큰 문제를 작은 하위 문제로 쪼개면서 재귀적으로 해결
  - 이미 계산한 하위 문제의 결과는 저장(메모이제이션)해서 중복 계산 방지
  - 주로 재귀 함수 + 캐시(배열, 딕셔너리) 사용

  - 예시 (피보나치 수열)
    ```python
    def fib(n, memo={}):
        if n <= 1:
            return n
        if n not in memo:
            memo[n] = fib(n-1, memo) + fib(n-2, memo)
        return memo[n]
    ```


**상향식(Bottom-Up, 타뷸레이션)**

  - 가장 작은 하위 문제부터 차례대로 해결해서, 점점 큰 문제로 확장
  - 반복문을 사용해서 DP테이블을 채움
  - 재귀 없이 순차적으로 계산

  - 예시 (피보나치 수열)
    ```python
    dp = [0, 1] + [0] * (n-1)
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
     ```


- **차이점 요약**

  - 하향식: 재귀 + 메모이제이션, 코드가 간결, 호출 스택 사용
  - 상향식: 반복문 + DP테이블, 메모리/속도 효율적, 스택 오버플로우 없음



- **문제 풀이에 적용하는 사고방식**

  ```
  1. DP로 풀 수 있는 문제인지 판단하기
     - 중복되는 하위 문제가 있는지, 최적 부분 구조가 성립하는지 확인
     ex)
       - 피보나치 수열은 n번째 항을 구할 때 n-1, n-2번째 항을 이용한다.
       - 같은 하위 문제가 여러 번 등장하므로 DP로 풀 수 있다.

  2. 상태(state) 정의하기
     - DP 테이블에 담긴 값이 무엇인지 명확히 설정
     - DP 테이블의 인덱스가 무엇을 의미하는지 명확히 설정
     ex)
       - dp[i]를 i번째 피보나치 수라고 정의한다.

  3. 점화식(transition) 세우기
     - 현재 상태를 이전 상태(또는 여러 상태)로부터 어떻게 계산할지 식을 세움
     ex)
       - dp[i] = dp[i-1] + dp[i-2]로 나타낼 수 있다.

  4. 메모이제이션 구조 설계하기
     - 1차원, 2차원, 혹은 더 복잡한 구조가 필요한지 결정
     ex)
       - n이 크지 않으므로 1차원 배열 dp를 사용한다.

  5. 초기값(base case) 설정하기
     - DP 테이블의 시작값을 올바르게 지정
     ex)
       - dp[0] = 0, dp[1] = 1로 시작한다.

  6. 최종 해답 위치 확인하기
     - DP 테이블의 어떤 값이 문제의 정답인지 파악
     ex)
       - dp[n]이 원하는 답이 된다.
  ```


- 선목님의 사고방식
  
  1. 일단 재귀든 뭐든 완전 탐색으로 풀어본다.
     - 안풀리면 패턴을 찾는다.
     - 풀리면 최적화한다.(DP)
    


## 주차별 회고


> [!lg] 정글입성
>
> - 웹 프로젝트
>
> [week-0](week/week-0)


> [!lg] 컴퓨팅 사고로의 전환
>
> - 알고리즘 (1~4주차)
>   : 챕터&키워드 + 실습(문제 풀기) + 시험 및 리뷰
>
> [week-1](week/week-1)
> [week-2](week/week-2)
> [week-3](week/week-3)
> [week-4](week/week-4)




## 공식일정

[입소식](입소식)

[정글생활 OT & 학점은행제 설명 2025-09-02](정글생활_OT_&_학점은행제_설명)

[반별 면담 2025-09-02](반별_면담)

[에세이 2025-09-05](에세이)

[팀별 면담 2025-09-09](팀별_면담_2025-09-09)

[알고리즘 특강 2025-09-12](알고리즘_특강_2025-09-12)

[커피챗_1 2025-09-16](커피챗_2025-09-16)


## ETC

[지원하기](지원하기)

[입소 전 준비](입소_전_준비)

[생활](생활)


## 비공개


[정글 캠퍼스 생활 안내(교육생 안내용)](외부비공개/정글_캠퍼스_생활_안내_교육생_안내용)
[학점은행제](외부비공개/학점은행제)
