

> [!qt] 프로세스가 커널모드로 또는 유저모드로 실행된다고도 하잖아. 커널모드로 실행된다는건 커널 프로세스(쓰레드)가 별도로 존재해서 그것으로 제어권이 넘어가는 방식인가?


좋은 질문입니다!  
**커널모드로 실행된다는 것**은 "커널 프로세스(쓰레드)가 별도로 존재해서 제어권이 넘어간다"는 의미와는 조금 다릅니다.

### 개념 설명

- **유저모드(User Mode):**  
  일반 프로그램(프로세스)이 제한된 권한으로 실행되는 상태입니다.  
  메모리, 하드웨어 접근 등이 제한됩니다.

- **커널모드(Kernel Mode):**  
  운영체제 커널 코드가 실행되는 상태입니다.  
  모든 자원에 접근할 수 있습니다.

### 제어권 이동 방식

- **프로세스가 커널모드로 실행된다**는 것은,  
  유저모드에서 실행 중인 프로세스(쓰레드)가 시스템 콜 등으로 커널 코드를 호출하면  
  **현재 실행 중인 쓰레드의 실행 컨텍스트가 커널모드로 전환**된다는 뜻입니다.

- **별도의 커널 쓰레드로 제어권이 넘어가는 것이 아니라**,  
  **현재 쓰레드가 커널모드로 전환되어 커널 코드를 실행**합니다.

- 커널 내부적으로 별도의 커널 쓰레드가 존재할 수도 있지만,  
  일반적인 시스템 콜 처리에서는 **유저 쓰레드가 커널모드로 진입**해서 커널 코드를 실행합니다.

### 예시

1. 유저 프로그램이 `read()` 시스템 콜을 호출함
2. CPU가 유저모드에서 커널모드로 전환됨
3. **현재 쓰레드가 커널모드에서 커널 코드를 실행**
4. 작업이 끝나면 다시 유저모드로 돌아감




---




> [!qt] 커널모드와 유저모드를 넘나드는 변경은 누가 해주는데?



커널모드와 유저모드의 변경(전환)은 **CPU가 해줍니다**.  
이 전환은 **특정 명령어(예: 시스템 콜, 인터럽트, 예외 등)**에 의해 자동으로 이루어집니다.

### 주요 방식

- **시스템 콜**:  
  유저모드 프로그램이 커널 기능을 요청할 때,  
  `syscall`, `int 0x80`(x86), `svc`(ARM) 같은 명령어를 실행하면  
  CPU가 **유저모드 → 커널모드**로 전환합니다.

- **인터럽트/예외**:  
  하드웨어 인터럽트나 예외가 발생하면  
  CPU가 자동으로 **커널모드**로 진입하여 커널의 인터럽트 핸들러를 실행합니다.

- **반환(Return)**:  
  커널 코드 실행이 끝나고 다시 유저모드로 돌아갈 때  
  CPU가 **커널모드 → 유저모드**로 전환합니다.

### 요약

- **전환의 주체**: CPU (하드웨어적으로 지원)
- **트리거**: 시스템 콜, 인터럽트, 예외 등



---



> [!qt] 예외 핸들러의 마지막 부분에 유저모드로 전환하는 명령이 있겠구나? 


맞습니다!  
예외 핸들러(또는 시스템 콜 핸들러)의 마지막 부분에는 **유저모드로 돌아가는 명령**이 반드시 있습니다.

### 동작 방식

- 예외나 시스템 콜이 발생하면 CPU가 커널모드로 진입하여 핸들러를 실행합니다.
- 핸들러가 작업을 마치면,  
  **CPU 명령어(예: `iret`, `sysret`, `eret` 등)**를 사용해  
  **유저모드로 복귀**합니다.

### 예시 (x86 아키텍처)

- `iret` (Interrupt Return):  
  커널모드에서 유저모드로 돌아갈 때 사용  
  스택에 저장된 유저모드의 레지스터, 플래그, 코드 위치 등을 복구하면서  
  CPU의 모드를 유저모드로 전환

### 요약

- 예외/시스템 콜 핸들러의 마지막에  
  **유저모드로 복귀하는 명령어가 반드시 존재**합니다.




---



> [!qt] 그러면 커널코드는 마치 C standard library처럼 각 프로세스에 shared link 방식으로 링킹되어있는거야?




아니요, 커널 코드는 **C standard library처럼 각 프로세스에 shared link 방식으로 링킹되어 있지 않습니다**.

### 차이점 설명

- **C standard library (예: libc.so)**  
  → 각 프로세스의 주소 공간에 **공유 라이브러리**로 매핑되어,  
  → 프로세스가 직접 함수 호출로 접근합니다.

- **커널 코드**  
  → **모든 프로세스와 완전히 분리된 별도의 주소 공간(커널 공간)에 존재**합니다.  
  → 프로세스는 직접 커널 함수를 호출할 수 없고,  
  → **시스템 콜, 인터럽트 등 특별한 메커니즘**을 통해서만 커널 코드가 실행됩니다.

### 동작 방식

- 유저 프로세스는 커널 코드를 직접 링크하거나 호출하지 않습니다.
- 커널 코드는 운영체제의 핵심 부분으로,  
  모든 프로세스가 **공통적으로 접근하지만 직접적으로 연결되어 있지 않습니다**.
- 커널 코드 실행 시에는 CPU가 커널모드로 전환되어,  
  커널의 주소 공간에서만 실행됩니다.

### 요약

- 커널 코드는 **공유 라이브러리처럼 각 프로세스에 링크되어 있지 않다**.
- 커널은 **독립적으로 메모리에 적재**되어,  
  시스템 콜/인터럽트 등으로만 접근 가능하다.




---



> [!qt] 그럼 커널 코드는 컴퓨터가 켜지면 항상 물리 메모리의 한쪽(커널 영역)에 상주해 있겠네?



맞습니다!  
커널 코드는 컴퓨터가 켜질 때 **항상 물리 메모리의 특정 영역(커널 영역)에 상주**합니다.

### 동작 방식

- 컴퓨터가 부팅되면,  
  부트로더가 커널 이미지를 **물리 메모리의 특정 위치**에 적재합니다.
- 커널은 그 이후로 **항상 메모리에 상주**하며,  
  시스템 전체를 관리합니다.
- 유저 프로세스와는 **주소 공간이 분리**되어 있어,  
  유저 프로세스가 직접 커널 영역에 접근할 수 없습니다.

### 요약

- 커널 코드는 **항상 메모리에 상주** (운영체제의 핵심)
- 커널 영역은 **보호된 메모리 공간** (유저모드에서 접근 불가)
