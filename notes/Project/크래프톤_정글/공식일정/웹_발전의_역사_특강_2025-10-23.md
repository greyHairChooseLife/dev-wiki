# 웹 발전의 역사 특강 2025-10-23




## TCP vs UDP

| Aspect          | TCP (Transmission Control Protocol)                                                                | UDP (User Datagram Protocol)                                                             |
|:---------------:|----------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|
| **Connection**  | Connection-oriented (requires 3-way handshake to establish)                                        | Connectionless (no setup needed), Just send data                                         |
| **Reliability** | Reliable: Ensures data arrives in order, with error checking, acknowledgments, and retransmissions | Unreliable: No guarantees; packets may be lost, duplicated, or arrive out of order       |
| **Speed**       | Slower due to overhead (e.g., handshakes, flow control)                                            | Faster, lower latency, minimal overhead                                                  |
| **Data Flow**   | Stream-based (continuous flow)                                                                     | Datagram-based (individual packets)                                                      |
| **Use Cases**   | Web browsing, email, file transfers (where accuracy matters)                                       | Video streaming, online gaming, DNS queries (where speed is prioritized over perfection) |
| **Example**     | Like a phone call: Establish connection first, then talk reliably                                  | Like sending mail: Drop it in the box and hope it arrives                                |

- TCP

  - ex) 전화연결: 연결이 이루어지고 나서야 통신이 가능하다.
  - 연결 방식
    - 3 way handshake
      ```
      Client                     Server
        |                          |
        |-------- SYN -----------> |
        |                          |
        | <------- SYN-ACK ------- |
        |                          |
        |-------- ACK -----------> |
        |                          |
      Connection
        established
      ```



- UDP

  - ex) 우편: 그냥 바로 보낸다.


## HTTP


_TCP 기반 프로토콜_


### HTTP 1.0

- `connect` and `close` for each pairs of req/res
- that causes overhead
  (e.g., repeated handshakes)


### HTTP 1.1

- `Connection: keep-alive` Header
- allowing persistent connections **to reuse TCP links** for multiple requests,
  reducing overhead.



### HTTP 2.0

- Multiplexing:
  Allows multiple req/res over a single connection, improving efficiency.

- Server Push
  enables the server to push resources to the client proactively without explicit requests.
  (via push promises)

  - usecases
    - Web Page Loading: When a client requests an HTML page, the server can push associated CSS
      and JavaScript files immediately, so the browser doesn't need to request them separately.

    - Image Galleries: For a photo gallery page, the server can push thumbnail images or the
      first few full-size images proactively, speeding up rendering.

    - Fonts and Icons: Pushing web fonts or icon sets along with the HTML, ensuring they're
      available without additional requests.

    - API Responses: In single-page apps, pushing related JSON data or assets when serving the
      initial HTML.




## Common Gateway Interface (CGI)


- CGI (Common Gateway Interface)

  A standard for web servers **to execute external programs** (e.g., scripts in Perl, Python) **to generate
  dynamic content.** Each request spawns a new process, which is simple but inefficient for high
  traffic.

  - CGI Process (per request):
    ```
    Cuient Request
          |
          v
    Web Server (e.g., Apache)
          |
          v
    Spawns CGI Process -> Executes Script -> Generates Response (as stdout)
          |
          v
    Sends Response to Client
    (Process dies after response)
    ```






- FastCGI

  An evolution of CGI that **keeps processes running** persistently, allowing reuse across requests.
  This reduces startup overhead, improving performance and scalability.

  Threads can be used as well.


  - FastCGI Process (persistent):
    ```
    Client Request
          |
          v
    Web Server
          |
          v
    FastCGI Process Pool (running continuously) or Threads
          |  (reuses for multiple requests)
          v
    Executes Script -> Generates Response
          |
          v
    Sends Response to Client
    ```






## 3 layer Architecture


- **Old Model**:
  ```
  Client (Handles View & Data Access Info)
        |
        v
  Datacenter/Database
  ```


- **3-Layer Architecture**:
  
  - It makes dynamic generation possible.

  ```
  Client (Browser)
        |
        v
    Web Server
        |
        v
  Presentation Layer (UI/Client)            # Layer 1
        |
        v
  Application Layer (Business Logic)        # Layer 2
        |
        v
  Data Layer (Database)                     # Layer 3
  ```



## Embedded Web Server


- ex) Flask, Node Express, ...

  ```
  Client (Browser)
        |
        |  (HTTP Request)
        v
  Web Environment (Python)
        |
        +-- Flask Web App
        |     - Routes requests
        |     - Processes logic
        |     - Generates responses
        |
        +-- Mini Web Server (Werkzeug, built into Flask)
        |     - Listens on port (e.g., 5000)
        |     - Serves static/dynamic content
        |     - For development only
        |
        v
  Database/API (if needed)
  ```



## Restful API


```
Client (Browser/App)
      |
      |  HTTP Request (e.g., GET /api/users)
      v
API Gateway
      |  (Routes, Authenticates, Load Balances)
      |
      +---------------------------------------+
      |                                       |
      v                                       v
App Server 1 (e.g., User Service)    App Server 2 (e.g., Post Service)
      |                                       |
      +-- API Endpoints                       +-- API Endpoints
      |
      v
Database (Shared or Per Service)
```


- API Gateway
  - reverse proxy server
  - load balancer
  - authorization
  - API documentation


- This is a case for using JWT instead of session.





## Content Delivery Network (CDN)


```
User (Client)
      |
      |  Request (e.g., image.jpg)
      |
      v
CDN Edge Server (Nearest Location)
      |
      |
      +-- Cache Hit? (Content available)
      |     Yes: Serve directly to User
      |
      |
      +-- Cache Miss? (Content not available)
      |     No: Fetch from Origin Server
      |         |
      |         |
      |         v
      |     Origin Server (e.g., Main Web Server)
      |         |
      |         |
      |         v
      |     Cache in Edge & Serve to User
```



## Monolithic vs MicroService Architecture


- 단순히 기술적 차이가 아니라 **조직관리 차원에서도 많은 이점이** 있다는 것이 인상깊었다.


- Monolithic:
  ```
  Client
        |
        v
  Monolithic App
        |
        +-- UI Layer
        +-- Business Logic
        +-- Data Access
        |
        v
  Database
  ```


- Microservices:
  ```
  Client
        |
        v
  API Gateway
        |
        +-------------------------------+
        |                               |
        v                               v
  Service 1 (e.g., User Mgmt)     Service 2 (e.g., Orders)
        |                               |
        +-- API Endpoints               +-- API Endpoints
        |
        v
  Databases (Per Service or Shared)
  ```
