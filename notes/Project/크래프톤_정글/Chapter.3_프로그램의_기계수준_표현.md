# Representation of Programs



[notebookLM](https://notebooklm.google.com/notebook/f405095d-572f-4992-bf85-e8781645f33a)


- **이 챕터의 목표:**

  C와 같은 고급 언어로 작성된 프로그램이 컴퓨터에서 실제로 어떻게 기계어(machine code)로 표현되고
  실행되는지를 이해하는 것이다.

    - 컴파일러의 최적화 능력을 파악하고
    - 프로그램의 잠재적 비효율성을 분석하며
    - 시스템 해킹과 같은 보안 취약점이 어떻게 발생하는지


- 목차

  1. Historical Perspective
  2. Program Encodings
  3. Data Formats
  4. Accessing Information
  5. Arithmetic and Logical Operations
  6. Control Flow
  7. Procedures
  8. Array Allocation and Access
  9. Heterogeneous Data Structures
  10. Combining Control and Data
  11. Floating-Point Code
  ~12. Summary~



## 기초     :  기계어의 본질과 표현

_기계어 프로그램을 본격적으로 분석하기 전에,
필요한 배경지식과 기본적인 개념을 소개합니다._

목표: 
  - 기계어는 궁극적으로 바이트(byte)의 연속일 뿐임을 이해함
  - 어셈블리 코드(assembly code)를 분석하는 것이 기계어를 이해하는 핵심적인 방법임을 알게됨

### Historical Perspective

- x86 계열의 진화와 하위호환성

  - 프로세서의 발전은 메모리 사용 방식, 인스트럭션 추가, 하이퍼쓰레딩 및 멀티코어 기술 적용
  - 점진적으로 개선되었고, 관련 소프트웨어도 있으니 하위호환성 지원
  - 따라서 용어의 혼재 및 하위호환성을 위해서만 존재하는 요소들이 있음


### Program Encodings


- 컴파일 시 최적화 단계를 지정할 수 있음
  - 컴파일 소요시간 대비 프로그램 성능 다름
  - 너무 높은 수준의 최적화는 디버깅을 어렵게 함


- 어셈블리 코드를 이해할 수 있고, 본래 C코드와 어떻게 연관되었는지 이해하는 것이 중요함

  - C언어와 기계어의 차이

    1. C언어에서는 프로세서 상태가 감추어져 있음
        - _프로그램 카운터 (%rip):_ 다음에 실행할 명령어의 주소를 가리킨다.
        - _정수 레지스터 파일:_ 주소(포인터)나 정수 데이터를 저장한다.
        - _조건 코드 레지스터:_ 연산 결과의 상태를 저장한다.
        - _벡터 레지스터:_ 여러 개의 정수/부동소수점 값을 저장한다.

    2. 기계어는 여러가지 종류의 데이터 타입(int, double, signed unsigned 등등)을 구분하지 않음
    3. 메모리를 바라보는 관점의 차이
       - C 언어: 추상화되어있으며, 자기 프로그램만의 공간을 상정함(가상 메모리 안에 소스코드, 힙, 스택 등)
       - 기계어: 그냥 거대한 바이트 덩어리와 접근할 수 있는 주소. 어떻게 해석할지 컨텍스트가 중요함

    4. 기계어는 그냥 바이트의 나열일 뿐
       - 이 바이트들은 1~15(x86의 경우)바이트 길이로 개별적인 인스트럭션들의 나열이다.



## 핵심 요소:  데이터와 연산


_기계어의 기본 구조를 이해했다면,
이제 프로그램의 가장 기본적인 두 요소인 '데이터'와 '연산'이 기계 수준에서 어떻게 다뤄지는지
학습합니다._


목표:

  - C코드 한 줄이 여러 개의 기계어 명령어로 번역될 수 있음을 알게됨
  - 특히 leaq 명령어처럼 주소 계산 명령어가 일반 산술 연산에 최적화되어 사용되는 흥미로운 사례를
    통해 컴파일러의 최적화 기법을 엿봄

### Data Formats

- C의 데이터 타입(int, char, 포인터 등) 마다 차지하는 바이트 수가 있고, 이것은 어셈블리어로
  번역된 코드에 나타나있다.

  _(어샘블리어 코드를 보면)_
  1. 인스트럭션의 나열이다.
  1. 인스트럭션에는 operand의 크기를 나타내는 접미어가 있다. (p.171 그림 3.1)
     - `b,w, l, q, ...등`

     - compile단계에서 생성된 어샘블리어 코드에서는 이 크기를 나타내준다.
     - 디버거나 objdump 따위로 생성한 역어샘블러 코드는 이것을 생략한 경우가 많다. 오퍼렌드 값을
       보고 쉽게 데이터 크기를 추측할 수 있기 때문이다.
       또는 동일한 이유로 정반대인 경우도 있다.
      
  1. 각 인스트럭션은 1~15B
  1. compile 단계에서 미완성된 부분을 링커가 채워준다. 어셈블러와 링커를 위한 지시문이
     있다.(`.`으 로시작함)


- 성능 등을 이유로 어셈블리어 코드를 직접 C언어 코드에 포함할수도 있다.
  - inline으로 넣을수도 있고, asm파일을 함수단위로 만들어서 링커에게 연결하도록 할수 있다.
  - 근데 그러면 특정 아키텍쳐에 국한되어 실행되는 기능이기 때문에 제한적으로 사용해야한다.


### Accessing Information


#### 범용 레지스터

**레지스터의 명명과 접근:**

- 정수값과 주소값이 저장
- 역사적 맥락에 따라 16b, 32b, 64b 시스템에서 다뤄지는 각각의 레지스터 capacity도 커지고,
  이에 따라 이름도 확장
- 개발자는 이 영역들중 무엇에 접근할지 선택

- 16개 범용 레지스터 (p.173 그림 3.2)


> [!qt]  64비트 시스템에서 작은 레지스터 이름을 사용하는 이유
>   󱞪 단순히 과거의 유산이 아니라, 다양한 데이터를 효율적으로 다루고 코드를 최적화하기 위해
>
>   - 데이터 타입 크기에 맞는 효율적 연산:
>     C언어의 int(4바이트), short(2바이트), char(1바이트) 등 다양한 크기의 데이터를 처리할 때, 그
>     크기에 딱 맞는 레지스터 이름(%eax, %ax, %al)과 명령어를 사용하면 더 빠르고 효율적입니다.
>   
>   - 하위 호환성 및 명령어 구조:
>     x86 아키텍처는 16비트에서 64비트로 점진적으로 확장되었습니다. 과거 버전과의 호환성을 위해
>     기존의 레지스터 접근 방식을 유지하고 있습니다.



**레지스터의 역할:**

대부분의 레지스터는 유연하게 사용될 수 있지만, 몇몇은 특별한 역할

- `스택 포인터(%rsp)`는 런타임 스택의 끝을 가리키는 매우 중요한 역할. 가장 최근 시점을
  뜻한다.(최근에 데이터가 저장되었다거나)
- 함수 인자 전달, 반환 값 저장, 지역 변수 및 임시 데이터 저장 등에 사용되며, 이는 표준
  프로그래밍 관습에 따름


#### 피연산자 지정 방식 (Operand Specifiers)

_대부분의 명령어는 연산에 사용할 소스(source) 값과 결과를 저장할 목적지(destination)를 지정하는
하나 이상의 피연산자를 가진다._

예시)
```asm
movq %rax, %rbx      # %rax의 값(숫자 또는 주소)을 %rbx에 복사
movq (%rax), %rbx    # %rax가 가리키는 메모리의 값을 %rbx에 복사
```


- x86-64에서는 세 가지 유형의 피연산자를 지원

  - 즉시값(Immediate): 상수 값
  - 레지스터(Register): 레지스터에 저장된 내용. 16개 레지스터의 하위 1, 2, 4, 8바이트 부분을
    피연산자로 사용
  - 메모리 참조(Memory Reference): 계산된 주소(유효 주소)를 통해 메모리 위치에 접근



- operand 괄호의 의미

  - 괄호가 없는 경우:
    레지스터에 들어있는 **값 자체**를 의미
    (그 값이 주소이든, 숫자이든, 그냥 그 값 자체를 사용)

  - 괄호가 있는 경우:
    레지스터에 들어있는 값을 **메모리 주소로 사용**해서,  
    그 주소에 저장된 **메모리의 실제 값**



#### 데이터 이동 명령어 (Data Movement Instructions)

_데이터를 한 위치에서 다른 위치로 복사하는 명령어는 프로그램에서 가장 빈번하게 사용되는 명령어
중 하나_


- `MOV`: 데이터 이동 명령어

  - 메모리 <=> 레지스터 간 복사만 허용
  - movb/w/l/q는 크기별
  - movabsq는 64비트 즉시값 이동


- `MOVZ/MOVS`: 작은 크기 => 큰 크기 복사

  - `movz`: 제로 확장
    (작은 크기의 값을 더 큰 크기의 레지스터로 옮길 때 남는 상위 비트(앞부분)를 0으로 채워서 저장)
  - `movs`: 부호 확장
    원래 값의 부호(음수/양수)를 유지하기 위해 남는 상위 비트(앞부분)를 값의 최상위 비트(부호
    비트)로 채워서 저장
  - `movl`: 상위 4바이트 0으로 채움
  - `cltq`: `%eax` => `%rax` 부호 확장


- `PUSH/POP`: 스택에 데이터 저장/복원

  _stack 영역은 상위 주소부터 사용하여 점점 아래로 뻗어나간다. 컨텍스트가 깊어질수록 더 낮은
  주소영역을 사용하고, 개별 컨텍스트에서 시작점은 최상단이다._

  _stack 영역의 가장 오래된 지점을 stack bottom, 최근 시점을 stack top이라 부른다. 그러니까
  스택포인터 레지스터(`%rsp`)는 항상 stack top이 되는거다._

  - 저장 또는 제거되는 데이터의 크기만큼 스택포인터(`%rsp`)가 이동한다.

    - pushq: 더 낮은 주소값으로 이동
    - popq : 위치 더 높은 주소값으로 이동


### Arithmetic and Logical Operations


_정수 값과 논리 값을 계산하는 데 사용하는 주요 명령어_


- **주소 계산 (Load Effective Address - `leaq`)**
  - 유효 메모리 주소를 계산하여 레지스터에 저장
  - 근데 메모리 주소 계산에만 사용하지 않고 일부 산술연산에 사용한다. 제한된 경우지만 효율이 좋다.

  - ex)
  ```asm
  leaq 8(%rbp), %rax      # %rbp + 8의 값을 %rax에 저장 (메모리 접근 X, 단순 계산)
  ```



- **단항 및 이항 연산 (Unary and Binary Operations)**

  - 단항 연산: 

    - `inc`: 증가
    - `dec`: 감소
    - `neg`: 부호 반전

    - ex)
    ```asm
    inc %rax                ## %rax 값을 1 증가
    dec %rbx                ## %rbx 값을 1 감소
    neg %rcx                ## %rcx 값을 부호 반전 (양수→음수, 음수→양수)
    ```


  - 이항 연산: 두 개의 피연산자를 받아 연산을 수행하고, 결과를 두 번째 피연산자에 저장

    - `add `: 덧셈
    - `sub` : 뺄셈
    - `imul` : 곱셈
    - `xor, or, and` : 논리 연산

    - ex)
    ```asm
    add %rbx, %rax          # %rax = %rax + %rbx
    sub %rcx, %rdx          # %rdx = %rdx - %rcx
    imul %rbx, %rax         # %rax = %rax * %rbx
    xor %rcx, %rdx          # %rdx = %rdx XOR %rcx
    or  %rbx, %rax          # %rax = %rax OR %rbx
    and %rcx, %rbx          # %rbx = %rbx AND %rcx
    ```


- **시프트 연산 (Shift Operations)**
  - 데이터의 비트를 왼쪽 또는 오른쪽으로 이동
  - 논리적 오른쪽 시프트 (`shr`): 왼쪽을  0으로 채움 (부호 없는 수에 사용)
  - 산술적 오른쪽 시프트 (`sar`): 왼쪽을 최상위 비트(부호 비트)로 채움 (부호 있는 수에 사용)
  - 왼쪽 시프트 (`sal 또는 shl`): 두 가지 이름이 있지만 기능은 동일

  - ex)
  ```asm
  shr $1, %rax            # %rax를 오른쪽으로 1비트 논리 시프트 (부호 없는 수)
  sar $1, %rbx            # %rbx를 오른쪽으로 1비트 산술 시프트 (부호 있는 수)
  shl $2, %rcx            # %rcx를 왼쪽으로 2비트 시프트 (sal도 동일)
  ```



- **특수 산술 연산 (Special Arithmetic Operations)**

  - 64비트 곱셈은 128비트 결과를 낸다.
    - `imulq` (부호 있음)
    - `mulq` (부호 없음)
    - 결과는 %rdx와 %rax 두 레지스터에 나뉘어 저장

  - 128비트 값을 64비트 값으로 나누는 나눗셈과 나머지 연산
    - `idivq` (부호 있음)
    - `divq` (부호 없음)

  - ex)
  ```asm
  imulq %rbx              # %rax = %rax * %rbx (128비트 결과: %rdx:%rax)
  mulq %rbx               # %rax = %rax * %rbx (부호 없음, 128비트 결과: %rdx:%rax)

  # %rdx:%rax를 %rbx로 나눔, 몫은 %rax, 나머지는 %rdx
  idivq %rbx              # 부호 있음
  divq %rbx               # 부호 없음
  ```




## 핵심 요소:  프로그램의 흐름 제어

_데이터를 조작하는 방법을 배웠으니,
이제 프로그램의 실행 흐름을 바꾸는 C의 제어 구조(if, switch, for, 함수 호출 등)가 어떻게 구현되는지
알아봅니다._

목표:

  - C에는 존재하는 반복문이나 조건문이 기계어에는 없다는 사실을 이해

    - 모든 제어 흐름은 "특정 조건을 검사해서 다른 곳으로 점프할지, 아니면 다음 명령어를 실행할지"
      결정하는 단순한 메커니즘으로 귀결
    - 특히 switch문이 점프 테이블(jump table)이라는 효율적인 자료구조로 구현되는 방식을 통해 성능
      최적화 기법을 깊이 있게 이해

  - 스택 프레임(stack frame)이라는 개념을 통해 각각의 함수 호출이 독립적인 공간을 가지게 되며, 이를
    통해 재귀 호출(recursion)도 가능해짐

  - 버퍼 오버플로우 공격이 스택에 저장된 반환 주소를 변조하여 발생한다는 것을 이해하는 기반을 닦음


### Control Flow


> _C언어가 직관적이고 추상적인 제어구조를 표현하지만, 기계어로 변환되면 '주로' 원시적인 두 가지
> 메커니즘에 의존함_
>
> 1. 데이터 값 테스트: 데이터 값을 테스트
> 2. 제어 흐름 변경: 설정된 조건 코드를 바탕으로 점프(`jump`) 명령어를 사용하여 프로그램의 실행
>    흐름을 변경
>    (다른것도 있긴 하다)


#### Condition Codes

- 주로 `cmp`(비교), `test`(특정 비트 테스트) 명령어

- **직전 연산** 결과의 속성을 **조건 코드(condition code)**라는 특정 레지스터에 1비트씩 저장됨

  | Flag |          이름 | 설명                    |
  |------|--------------:|-------------------------|
  | `ZF` |     Zero flag | 연산 값이 0인지 여부    |
  | `SF` |     Sign flag | 연산 값이 음수인지 여부 |
  | `OF` | Overflow flag | signed overflow 여부    |
  | `CF` |    Carry flag | unsigned overflow 여부  |


#### Accessing Condition Codes


_조건코드를 아래의 방식들로 상용함_


1. `SET` 

  조건을 값으로 변환하여 레지스터에 저장 



2. `JUMP`

  `Condition Code`를 확인하여 실행 흐름을 분기. 조건이 부합하면 프로그램 카운터(`%rip`)에
  다른 주소값을 할당. if-else, while, for 등에서 사용한다.



3. `CMOV`(**Conditional Move**, 조건부 데이터 선택)


  - 현대 프로세서의 성능 최적화를 위해 도입된 고급 제어 방식
  - 점프를 사용하지 않고, 조건 코드에 따라 소스 피연산자의 값을 목적지 레지스터로 복사할지 여부를 결정

  - jump방식과의 차이
    - jump(전통적) 방식: **분기 예측이 실패할 경우** 큰 성능 저하
    - 조건부 데이터 선택 방식: if/else 양쪽 결과 모두 계산, 조건 코드에 따라 cmov 명령어로 올바른 결과값만 최종 선택
    - 양쪽 결과를 모두 계산하는 비용이 단점이라, 간단한 연산에 사용

    > [!qt] 왜 분기를 예측 하는가?
    >    
    > - 현대 프로세서는 높은 성능을 위해 Pipelining 기술을 사용
    > - 파이프라이닝: 하나의 명령어를 실행하는 과정을 여러 단계로 나누고, 각 단계를 동시에 처리
    >   (예: 명령어 가져오기, 명령어 해석, 데이터 읽기, 연산 수행, 결과 저장 등)
    > - 파이프라인이 계속 가득차 있어야 프로세서는 최대 성능
    > - 그래서 if-else, while 등 조건부 점프를 만나도 일단 예측하여 파이프라인을 채움(== 분기예측)
    > - 만약 예측에 실패하면 15~30클럭 사이클의 성능저하(통상 연산 1회에 1클럭)
    >   (현대 프로세서는 약 90% 예측 성공)



  - **제어의 흐름(control flow)을 데이터의 흐름(data flow)으로 변환**하는 대표적인 예

    > - 제어 흐름(Control Flow):  
    >
    >   if/else, for, while, goto, jump 등 **분기(branch)** 명령어로 프로그램의 실행 경로가 달라짐  
    >
    >   ```
    >   # 이 코드는 내부적으로 분기(jump) 명령어를 사용함
    >   
    >   if (cond) {
    >       x = a;
    >   } else {
    >       x = b;
    >   }
    >   ```
    >
    >
    > - 데이터 흐름(Data Flow):  
    >
    >   분기하지 않고, **모든 데이터를 계산한 뒤 조건에 따라 필요한 값만 선택**  
    >   ```
    >   x = cond ? a : b;
    >   ```
    >
    >   또는, 어셈블리에서 `cmov` 명령어로  
    >   - a, b 모두 계산  
    >   - cond가 참이면 a를, 거짓이면 b를 x에 복사




#### Jump Instructions


**점프의 두 가지 방식**

  1. 무조건 점프 `jmp`: 지정된 레이블(주소)로 프로그램의 PC(`%rip`)를 즉시 이동
  2. 조건부 점프 `je, jg 등`: 조건 코드에 따라 점프 여부 결정




**분기예측**

- 최적화 위해 파이프라이닝 기법
- 단, 예측 실패시 패널티 큼(현대는 90% 이상 적중)
- 이에 대응하여 cmov 같이 여러 경우를 모두 계산해버리기도 함(단, 비용 고려해야함)




**점프(`jump`) 명령의 인코딩**

- jump는 곧 PC(`%rip`)의 수정
- 대부분의 jump명령은 상대주소(relative addressing)를 지정함

  - 상대주소 방식: instruction의 절대값 주소 대신 (순차적으로 볼 때)직후 pc로부터의 상대적 offset을 기록
  - 왜? 
    - 가까운 거리를 점프할 때는 1~2B로 표현가능
    - 재배치 가능성(relocatability): 링커가 하나의 실행파일 만들 때 여러 코드블록 주소가
      바뀔 수있음. 이때에도 별도로 수정하지 않아도 되니까.

    > [!qt] 왜 직후 pc값을 offset 기준으로 삼을까?
    >   󱞪 과거엔 processor가 인스트럭션을 실행할 때 첫번째 단계가 프로그램 카운터를 갱신했다.
  

- 어샘블리 코드에서 jump 목적지는 레이블(Lable)로 표시함
  ````asm
      CMP AX, BX
      JE  .L2         ; 같으면 .L2로 점프
      JG  .L3         ; 크면 .L3로 점프
      JL  .L4         ; 작으면 .L4로 점프

  .L2:
      ; AX == BX일 때 실행
      JMP .L5
  .L3:
      ; AX > BX일 때 실행
      JMP .L5
  .L4:
      ; AX < BX일 때 실행
  .L5:
      ; 공통 종료 지점
  ````


#### Implementing Conditional Branches & Conditional Data Transfers

_- 기계어 코드는 단순히 C 코드를 일대일로 번역한 것이 아님_
_- 하나의 소스코드가 다양한 결과물로 나타날 수 있음_
_- 컴파일러는 프로세서에 따라 C 코드의 구조와는 다른 방식으로 코드를 재구성하여 성능을 극대화_


- 제어흐름은 아래의 두 가지 방식으로 조절됨

  1. 조건부 제어 이동: 전통적인 방식으로, `conditoin code`와 `jump`를 이용
  2. 조건부 데이터 이동: 현대 프로세서의 분기예측 성능 특성을 고려한 최적화



- > [!nt] 조건부 데이터 이동의 한계
  >
  >  모든 경우에 사용할 수 없다.
  >
  >  가장 중요한 한계는 양쪽 경로를 모두 평가하기 때문에 발생할 수 있는 부작용, 오류이다.
  >
  >  예를 들어, cread 함수(return (xp ? *xp : 0);)를 조건부 이동으로 구현하면, xp가 널 포인터일
  >  때도 *xp를 역참조하려는 시도가 발생하여 오류를 이르킨다. 이처럼 유효하지 않은 메모리 접근이나 값을
  >  변경하는 부작용이 있는 경우에는 반드시 전통적인 조건부 제어 이동(점프)을 사용해야 한다.




#### Loops


_- 고급 언어 수준에서의 다양한 추상화가 기계어 수준에서 단순화됨_
_- 컴파일러의 최적화 전략을 이해하고 있는것이 중요함_
_- 역엔지니어링의 중요성(내가 짠 코드와 다른 결과물이 나옴)_


> "반복문 또한 조건부 분기 메커니즘을 응용하여 구현되는 제어 흐름일 뿐"
> 
>   1. 루프 본문 실행          _<= 이놈이 추가되었을 뿐, 기본 양상이 같다._
>   2. 조건 테스트(cmp, test)
>   3. jump


---


1. **do-while Loop**

  - 루프 본문 실행
  - 조건 테스트
  - jump



2. **while Loop**

  루프 본문 실행 전에 조건을 먼저 테스트. _두 가지_ 전략이 있다.

  - Jump-to-Middle:
    - 낮은 최적화 레벨(-Og)에서 사용
    - 루프 시작 전에 무조건 점프(jmp)를 사용하여 루프의 끝에 있는 테스트 코드로 이동

  - Guarded-Do:
    - 높은 최적화 레벨(-O1)에서 사용
    - 루프에 진입하기 전에 먼저 조건을 검사하는 '가드(guard)'를 둠
      - 조건이 거짓이면 조건부 점프를 통해 루프 전체를 건너뜀 
      - 조건이 참이면, 이후의 루프는 do-while 루프와 동일한 구조로 실행
      - 컴파일러는 이 과정에서 루프 조건을 최적화



3. **for Loop** 

  - for 루프를 먼저 while 루프 형태로 변환
  - while 루프 번역 전략 중 하나를 적용




4. **switch**

  _- 제어 흐름이 어떻게 데이터 구조와 영리하게 결합하여 효율성을 극대화하는지를 보여주는 사례_
  _- if-else의 연속으로 인코딩 될 수도 있고, 다른 방식일수도 있고 컴파일러가 판단한다._

  - jump table의 활용
    - case마다 실행해야할 구문의 주소값이 들어있음
  - case 조건에 따라 계산된 인덱스를 사용하여 jump table 배열에서 인덱싱
  - case 숫자와 실행시간이 무관함



### Procedures



> [!nt] Procedure 메커니즘 이해의 중요성
>
> - **성능 최적화**: 함수 호출에는 스택 조작, 레지스터 저장 등 오버헤드가 발생하므로, 이를
>   이해하면 인라인 확장 등 컴파일러 최적화의 필요성과 성능에 민감한 코드에서 함수 호출 관리
>   방법을 알 수 있습니다.
>
> - **보안 취약점**: 함수 호출 시 스택에 저장되는 반환 주소와 지역 변수의 구조를 이해하면, 버퍼
>   오버플로우 같은 보안 취약점의 원인과 스택 보호 기법의 동작 원리를 파악할 수 있습니다.
>
> - **디버깅 및 리버스 엔지니어링**: 함수 호출의 기계 수준 동작을 알면, 디버깅 도구(gdb 등)로
>   스택 프레임을 분석해 오류 원인을 효과적으로 추적할 수 있습니다.


_- 고급 언어에서는 단순히 함수를 호출하고 값을 반환받지만,
  기계 수준에서는 일련의 정교한 메커니즘이 필요_




1. **제어 전달 (Passing control)**

  > 한 프로시저(호출자, caller)에서 다른 프로시저(피호출자, callee)로 실행 흐름을 넘겨주고,
  > 피호출자의 실행이 끝나면 다시 호출자의 올바른 위치로 돌아오는 과정
  > 
  > 
  > - `call` 명령어: 프로시저를 호출
  > 
  >   call은 돌아올 주소(return address), 즉 call 명령어 바로 다음 명령어의 주소를 스택(stack)에
  >   푸시(push)한 후, 호출할 프로시저의 시작 주소로 프로그램 카운터(PC)를 점프
  > 
  > 
  > - `ret` 명령어: 프로시저 실행을 마치고 복귀할 때 사용
  > 
  >   - 스택에 저장된 복귀 주소를 팝(pop)하여 프로그램 카운터에 로드함으로써 호출자에게 제어권을 돌려줌



2. **데이터 전달 (Passing data)**

  > 호출자가 피호출자에게 **인자(arguments)**를 전달하고, 피호출자가 호출자에게 **반환 값(return value)**
  > 을 돌려주는 과정
  > 
  > 
  >   - 레지스터 사용: 
  >     - x86-64 아키텍처에서는 성능을 위해 가능한 레지스터를 통해 데이터를 전달
  >     - 최대 6개의 정수 또는 포인터 인자는 `%rdi, %rsi, %rdx, %rcx, %r8, %r9` 레지스터 순서로 전달
  > 
  >   - 스택 사용: 
  >     - 6개를 초과하는 인자는 스택을 사용
  >     - 호출자는 호출 전에 추가 인자들을 **자신의 스택 프레임**에 저장
  > 
  >   - 반환 값:
  >     프로시저의 반환 값은 일반적으로 **%rax 레지스터**를 통해 전달



3. **메모리 할당 및 해제 (Allocating and deallocating memory)**

  > - 프로시저가 실행되는 동안 필요한 **지역 변수(local variables)**를 위한 메모리 공간을 확보하고,
  >   프로시저 종료 시 이를 해제하는 과정
  > 
  >   - 런타임 스택(Run-Time Stack):모든 과정의 중심
  > 
  >   - 스택 프레임(Stack Frame): 프로시저가 호출될 때마다 **해당 프로시저를 위한 메모리 공간인 스택
  >     프레임**이 스택의 **최상단**(stack-top)에 할당 
  >     - 이 프레임에는 
  >       - 반환 주소
  >       - 저장된 레지스터
  >       - 지역 변수
  >       - 다른 함수에 전달할 인자 등
  > 
  >   - 레지스터 저장 규칙: 여러 프로시저가 **레지스터를 공유**, 특정 **레지스터 값을 호출 전후에 보존하기 위한 약속이 필요**
  >     - 피호출자 저장(callee-saved) 레지스터(%rbx, %rbp, %r12–%r15)는 피호출 함수가 값을 보존
  >       - 자기가 레지스터 쓰면 데이터가 덮어씌워지니까 돌려줄 때 대비해서 미리 저장해 두는것
  >     - 호출자 저장(caller-saved) 레지스터는 호출 함수가 필요 시 직접 저장



#### Run-Time Stack


1. **제어 전달(Passing Control) 지원**

한 함수(호출자, caller)에서 다른 함수(피호출자, callee)로 제어 흐름을 넘기고, 실행이 끝나면
원래 위치로 정확하게 돌아오는 것

*   **반환 주소(Return Address) 저장**
프로시저 P가 Q를 호출할 때 `call` 명령어는 Q가 실행을 마친 뒤 돌아와야 할 P의 코드 주소, 즉 **반환 주소(return address)**를 런타임 스택에 **푸시(push)** 
``이 주소는 `call` 명령어 바로 다음 명령어의 주소입니다.
*   **복귀:** 프로시저 Q가 실행을 마치고 `ret` 명령어를 실행하면, 스택의 최상단에 저장된 반환 주소를 **팝(pop)**하여 프로그램 카운터(PC)에 로드합니다. 이를 통해 프로그램은 정확히 호출했던 지점으로 돌아가 실행을 재개할 수 있습니다.
*   **재귀 및 중첩 호출:** 스택의 후입선출 방식 덕분에 여러 프로시저 호출이 중첩되거나 재귀 호출이 발생해도 문제가 없습니다. 각 `call`은 자신만의 반환 주소를 스택에 순서대로 쌓고, 각 `ret`은 가장 최근에 쌓인 주소부터 꺼내어 복귀하기 때문에 제어 흐름이 꼬이지 않습니다.

### 2. 데이터 전달(Passing Data) 지원

프로시저는 인자(arguments)를 전달받고 결과 값을 반환해야 합니다. x86-64 아키텍처는 성능을 위해 최대 6개의 정수/포인터 인자를 레지스터를 통해 전달하지만, 그 이상의 인자는 런타임 스택을 통해 전달됩니다.

*   **스택 기반 인자 전달:** 호출자는 7번째 이후의 인자들을 호출 전에 자신의 **스택 프레임(stack frame)**에 저장합니다. 피호출자는 스택 포인터(`%rsp`)를 기준으로 특정 오프셋에 접근하여 이 인자들을 읽을 수 있습니다. 예를 들어, `proc` 함수는 7번째와 8번째 인자를 각각 `8(%rsp)`와 `16(%rsp)`에서 읽습니다 (반환 주소가 스택에 푸시된 후의 오프셋 기준).

### 3. 지역 저장 공간(Local Storage) 할당 및 해제

프로시저는 실행 중에만 필요한 **지역 변수(local variables)**나 임시 데이터를 저장할 공간이 필요합니다. 런타임 스택은 이러한 메모리를 동적으로 할당하고 해제하는 효율적인 메커니즘을 제공합니다.

*   **스택 프레임 할당:** 프로시저가 호출되면, 해당 프로시저만을 위한 메모리 공간인 **스택 프레임**이 스택의 최상단에 할당됩니다. 이 공간은 스택 포인터(`%rsp`)를 필요한 크기만큼 감소시켜서(스택은 낮은 주소로 자라므로) 확보합니다. `caller` 함수의 예시처럼, 지역 변수를 위한 16바이트 공간을 `subq $16, %rsp` 명령어로 할당합니다.
*   **지역 변수 저장:** 스택 프레임 내에 지역 변수를 저장하는 경우는 다음과 같습니다.
    1.  레지스터 개수가 부족할 때
    2.  지역 변수에 주소 연산자(`&`)를 사용하여 주소를 알아내야 할 때.
    3.  지역 변수가 배열이나 구조체일 때.
*   **레지스터 저장:** 프로시저가 **피호출자-저장(callee-saved)** 레지스터(`%rbx`, `%rbp` 등)를 사용하려면, 호출자의 값을 훼손하지 않기 위해 원래 값을 스택에 푸시하여 보존했다가 복귀 직전에 팝하여 복원해야 합니다. 이는 스택 프레임의 "저장된 레지스터" 영역에 해당합니다.
*   **스택 프레임 해제:** 프로시저가 반환될 때, 스택 포인터를 원래 위치로 복원(예: `addq $16, %rsp`)함으로써 할당했던 스택 프레임을 간단하게 해제합니다.

결론적으로, **런타임 스택은 프로시저라는 C 언어의 핵심 추상화를 기계 수준에서 구현하기 위한 필수적인 데이터 구조**입니다. 스택은 제어 흐름(반환 주소), 데이터 전달(인자), 지역 메모리 관리(스택 프레임, 지역 변수, 레지스터 저장)라는 프로시저의 세 가지 핵심 요소를 모두 지원하며, 이 모든 것을 "후입선출"이라는 간단하면서도 강력한 원칙하에 통합적으로 관리합니다. 이 스택 메커니즘을 이해하는 것은 함수 호출의 오버헤드, 재귀의 동작 원리, 그리고 버퍼 오버플로우와 같은 보안 취약점이 발생하는 이유를 파악하는 데 매우 중요합니다.





#### Control Transfer

abc
abc


#### Data Transfer


abc
abc


#### Local Storage on Stack

abc
abc

#### Local Storage in Registers


abc
abc


## 고급 요소:  고급 데이터 구조


_이제까지 배운 지식을 총동원하여
배열, 구조체와 같은 복합 데이터 타입과 부동소수점 연산이 기계 수준에서 어떻게 처리되는지 살펴봅니다._


목표:

  - C의 포인터가 실제로는 메모리 주소이며, 배열 접근(`a[i]`)과 포인터 연산(`*(a+i)`)이 기계
    수준에서는 동일한 주소 계산으로 구현된다는 것을 명확히 이해


### Array Allocation and Access

  - 복합 데이터 타입(배열, 구조체(struct), 공용체(union))이 메모리에 어떻게 연속적으로 할당되는지
  - 각 요소에 어떻게 접근하는지



### Heterogeneous Data Structures

  - 특히, 포인터 연산이 주소 계산으로 번역되는 과정과 데이터 정렬(alignment)의 중요성




## 응용     :  보안 및 특수 연산

    
### Combining Control and Data

(포인터에 대한 깊은 이해를 바탕으로)

- 배열의 경계를 벗어난 쓰기(out-of-bounds write)가 어떻게 버퍼 오버플로우(buffer overflow)
  공격으로 이어지는지 구체적으로 분석

- 방어하기 위한 최신 기술들: 스택 랜덤화, 스택 보호 기법(카나리 값) 등



### Floating-Point Code

- 정수 연산과는 다른 별도의 레지스터(XMM/YMM)와 명령어 집합을 사용하는 부동소수점 연산이 어떻게 처리되는지

