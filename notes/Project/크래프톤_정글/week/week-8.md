# week-8: Proxy Lab



> [!NOTE]
>
> 팀원: 김태성 + 권동민



> [!rf]
> 
> https://www.youtube.com/watch?v=V6CohFrRNTo
> https://www.youtube.com/watch?v=LtXEMwSG5-8


- server
  - create socket
  - connect
  - listen
  - read/write

- client
  - create socket
  - connect to the remote server
  - read/write



- 코어타임

  - 과제는 하나의 레포로 같이 한다!!!
  - 일단 10장, 11장 차례로 끝내기
    - [x] 10 장 완료
    - [x] 11장은 일단 11.4까지만 보고 echo 서버 완성해보기
      - Fri, 17:00 까지



> [!td]
>
> - [x] part1
> - [ ] part2
> - [ ] part3




## (팀)코어타임 기록


### 0차 2025-10-23 (목) 15:00

이번 주차에는 특이하게 한번씩 같은팀 해봤던 분들이랑 만났다. 마침 성향이 "같이 뭐 해보자!"인
사람들이 모인 덕분에 우리는 공부도 같이 과제도 같이 해가기로 했다. 하나의 저장소를 운영하기로
했는데, 과연 잘 될까 모르겠지만 일단 해보기로 했다.

이러나 저러나 재미있을것 같다.


### 1차 2025-10-23 (목) 23:00

목요일 전 날마다 거의 밤을 새니까, 너~~ 무 졸려서 그냥 한시간쯤 잤다. 1.5시간 정도 남았는데,
notebookLM의 도움을 받아서 최대한 약속한 부분까지 읽었다. 그래도 스무장 가량밖에 없어서 할만했다.

요약된 버전으로 바꿔서 읽다보니 우리들 모두 듬성듬성한 부분이 있었는데, 같이 공부한 것을 나누면서
합치다보니 혼자 했을 때보단 훨씬 완성도 있는 상태에 이르게 되었다.

역시 같이하는게 재밌고 유익하다.

### 2차 2025-10-24 (금) 23:00

아침에 나와보니까 동민님이 혼자 회의실에서 공부중이셨다. 같이 해도 되냐고 물어보고, 태성님도
불러서 다 같이 공부했다. 잔잔한 배경음악도 틀어놓고 가을 풍경을 바라보면서 공부했다.

지금생각해보니 태성님은 창을 등지고 계셔서 화면이 잘 안보였으려나? 맥북은 충분히 밝아서
괜찮았으려나?

하여튼 종일 같이 공부하고, 약속한 다섯시부터는 코어타임을 가졌다. 23:00까지 쭈욱.


다들 이해도가 조금씩 부족한 상태로 이야기를 시작했는데, 그래서 그런건지 뭔지 하여튼 우리는 의문도
많이 가지게 돼고 그래서 더 찾아보거나 논의하면서 찐하게 공부했다. 재밌고 유익했다.


## Proxy Lab


- 테스트용 명령, 코드라인

```
telnet www.cmu.edu 80
GET /hub/index.html HTTP/1.0

GET http://www.cmu.edu/hub/index.html HTTP/1.1
GET http://www.cmu.edu:58091/hub/index.html HTTP/1.1

GET http://localhost:5000/ HTTP/1.1
GET http://localhost:5000/sdf HTTP/1.1



tiny: 5000
proxy: 5001


home.html
http://localhost:5000/home.html


curl --max-time 5 --proxy http://localhost:5001 --output home.html http://localhost:5000/home.html

curl --max-time 5 --proxy http://localhost:5001 --output csapp.c http://localhost:5000/csapp.c
curl --max-time 5 --output csapp.c http://localhost:5000/csapp.c


diff -q .proxy/csapp.c .noproxy/csapp.c &> /dev/null
```


### Part. I

- 순차적 웹 프록시

    - 프록시가 들어오는 연결을 수락하고, 클라이언트 요청을 읽고 파싱하며, 웹 서버에 자체 연결을
      설정하여 요청을 전달하고, 서버 응답을 읽어 클라이언트에게 응답을 전달하는 과정으로 구성됩니다.

    - 이 구현은 기본 HTTP 작동 방식과 소켓(sockets)을 이용한 네트워크 통신 방법을 배우는 데 중점을 둡니다.


#### I. 프록시 실행 및 기본 처리

- 프록시는 명령줄 인수로 지정된 포트 번호에서 들어오는 연결을 수신 대기해야 합니다.

- 처리 대상 요청은 기본적으로 **HTTP/1.0 GET 요청**이며, POST와 같은 다른 요청 유형은 구현할 필요가 없습니다 (strictly optional).

- 프록시는 오류에 견고해야 하며, 세그먼트 오류(segmentation faults)나 메모리 누수(memory leaks) 없이 작동해야 합니다.


#### II. HTTP 요청 파싱 및 변환

- **요청 파싱:**
    - 프록시는 클라이언트의 요청 전문을 읽고 파싱해야 합니다.
    - 요청 라인(예: `GET http://www.cmu.edu/hub/index.html HTTP/1.1`)에서 최소한 다음 두 필드를 파싱해야 합니다:
        - 호스트 이름 (Hostname, 예: `www.cmu.edu`)
        - 경로 또는 쿼리 (Path or query, 예: `/hub/index.html`)

- **버전 변환:**
    - 현대 웹 브라우저가 HTTP/1.1 요청을 보내더라도, 프록시는 이를 처리하여 최종 웹 서버로 전달할 때는 **HTTP/1.0 요청**으로 변환해야 합니다.
    - *예시:* 클라이언트 요청이 `... HTTP/1.1`이면, 프록시는 서버에 `GET /path HTTP/1.0` 형태로 요청해야 합니다.

- **요청 형식:**
    - 모든 HTTP 요청 라인은 캐리지 리턴(`\r`)과 개행 문자(`\n`)로 끝나야 합니다.
    - 모든 HTTP 요청은 빈 줄(`"\r\n"`)로 종료됩니다.

- **견고성:**
    - 프록시는 요청이 잘못된 형식일지라도 조기에 종료되어서는 안 됩니다.
    - HTTP/1.0 사양(RFC 1945)에 따라 견고해야 하지만, 다중 라인 요청 필드(multiline request fields)를 처리할 필요는 없습니다.


#### III. 필수 요청 헤더 처리

프록시가 최종 웹 서버로 요청을 전달할 때, 다음 네 가지 헤더는 필수적으로 처리되어야 합니다.

- **Host 헤더:**
    - 항상 전송해야 합니다.
    - 클라이언트(브라우저)가 이미 Host 헤더를 보냈다면, 프록시는 그 헤더를 그대로 사용해야 합니다.
    - 이 헤더는 최종 서버의 호스트 이름을 명시합니다 (예: `Host: www.cmu.edu`).

- **User-Agent 헤더:**
    - 클라이언트를 식별하며, 서버가 콘텐츠를 조정하는 데 사용됩니다.
    - 특정 문자열(예: `User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3`)을 항상 전송하는 것이 권장됩니다.

- **Connection 헤더:**
    - 항상 `Connection: close`를 전송해야 합니다.

- **Proxy-Connection 헤더:**
    - 항상 `Proxy-Connection: close`를 전송해야 합니다.

- **헤더 사용 목적:** `close`를 명시함으로써, 프록시는 요청마다 새 연결을 열고 첫 번째 요청/응답 교환 후에 연결을 닫을 것임을 서버에 알립니다.

- **추가 헤더:** 브라우저가 보낸 다른 요청 헤더가 있다면, 프록시는 이를 변경 없이 웹 서버로 전달해야 합니다.


#### IV. 포트 번호 처리

- **프록시 수신 포트:**
    - 프록시는 명령줄 인수로 지정된 포트에서 연결을 수신 대기해야 합니다.
    - 1,024보다 크고 65,536보다 작은 비특권 포트(non-privileged port)를 사용해야 합니다.

- **HTTP 요청 포트:**
    - URL에 포트 번호가 포함될 수 있습니다 (예: `http://www.cmu.edu:8080/path`).
    - 포트 번호가 명시된 경우, 프록시는 해당 포트(예: 8080)로 서버에 연결해야 합니다.
    - 포트 번호가 URL에 포함되지 않은 경우, 기본 HTTP 포트인 **포트 80**을 사용해야 합니다.



### Part. II


구현된 순차적 웹 프록시를 확장하여 **다중 동시 요청**을 처리할 수 있도록 업그레이드하는
과제입니다. 이 과정은 시스템의 핵심 개념인 동시성(concurrency)을 다루는 방법을 소개하는 데
중점을 둡니다.



- **Part II 목표**

    - 작동하는 순차적 프록시를 변경하여 여러 요청을 동시에 처리할 수 있도록 해야 합니다.



- **동시성 구현 전략**

    - 동시 서버를 구현하는 가장 간단한 방법은 **새로운 연결 요청마다 새 스레드를 생성**하는
      것입니다.

    - 다른 설계 방식, 예를 들어 교과서 12.5.5절에 설명된 사전 스레드 서버(prethreaded server)
      방식도 가능합니다.

    - **스레드 관리 요구 사항:** 메모리 누수(memory leaks)를 피하기 위해 스레드는 반드시
      **분리된 모드(detached mode)**로 실행되어야 합니다.




- **스레드 안전성 관련 힌트**

    - CS:APP3e 교재에 설명된 `open clientfd` 및 `open listenfd` 함수는 현대적이고 프로토콜
      독립적인 `getaddrinfo` 함수를 기반으로 하므로, **스레드 안전(thread safe)**하게 사용할 수 있습니다.

    - 네트워크 프로그래밍 및 동시 프로그래밍에 관한 유용한 정보는 교과서 Chapter 10~12를 참조할 수 있습니다.




### Part. III


Part III는 프록시에 **캐싱(Caching)** 기능을 추가하여 최근 사용된 웹 객체를 메모리에 저장하도록
구현하는 과제입니다. 이 기능은 시스템의 성능을 향상시키기 위한 핵심 요소입니다.



- **목표:** 웹 객체의 메인 메모리 캐시를 추가하여, 동일한 객체 요청에 대해 원격 서버와 다시
  통신하는 것을 방지합니다.



- **작동 방식:**

    - 프록시는 서버로부터 웹 객체를 수신하는 동안, 해당 객체를 메모리에 캐시하면서 클라이언트에게
      동시에 전송해야 합니다.

    - 다른 클라이언트가 동일한 객체를 요청하면, 프록시는 서버에 재연결하는 대신 캐시된 객체를
      재전송할 수 있습니다.


- **접근 방식:** HTTP가 정의하는 복잡한 캐싱 모델 대신 간소화된 접근 방식을 채택합니다.



#### 캐시 크기 제한


프록시 캐시는 메모리 제한 문제를 방지하기 위해 최대 크기가 설정되어 있습니다.

- **최대 캐시 크기 (`MAX_CACHE_SIZE`)**
    - 전체 프록시 캐시의 최대 크기는 **1 MiB**입니다.
    - 이 크기를 계산할 때, 프록시는 실제 웹 객체를 저장하는 데 사용된 바이트만 포함해야
    합니다. 메타데이터와 같은 추가적인 바이트는 무시되어야 합니다.
- **최대 객체 크기 (`MAX_OBJECT_SIZE`)**
    - 개별 웹 객체의 최대 크기는 **100 KiB**입니다.
    - 이 크기를 초과하는 객체는 캐시해서는 안 됩니다.



#### 캐싱 전략 및 구현


- **객체 축적 및 버림:**

    - 가장 구현하기 쉬운 방법은 활성 연결마다 버퍼를 할당하여 서버로부터 수신되는 데이터를
      축적하는 것입니다.

    - 버퍼 크기가 `MAX_OBJECT_SIZE`를 초과하면, 해당 버퍼는 폐기되어야 합니다.

    - 최대 객체 크기를 초과하지 않은 상태에서 웹 서버의 응답 전체가 읽히면, 해당 객체는 캐시될
      수 있습니다.

    

- **축출 정책 (Eviction Policy):**

    - 캐시는 **LRU(Least-Recently-Used) 축출 정책을 근사**하는 정책을 채택해야 합니다.

    - 객체를 읽는 행위와 쓰는 행위 모두 객체를 '사용'한 것으로 간주되어야 합니다. 엄격하게
      LRU를 구현할 필요는 없으며, 합리적으로 근접한 정책이면 충분합니다.



#### 동기화 및 스레드 안전성


Part II에서 도입된 다중 스레드 환경에서 캐시 접근 시 경쟁 조건(race conditions)이 발생하지
않도록 스레드 안전성(thread-safe)을 보장하는 것이 중요합니다.


- **스레드 안전성 요구 사항:**

    - 캐시에 대한 접근은 반드시 스레드 안전해야 합니다.
    - 다중 스레드가 캐시에서 **동시에 읽는 것(Readers)**은 허용되어야 합니다.
    - 캐시에 **쓰는 것(Writers)**은 한 번에 하나의 스레드만 허용되어야 합니다.


- **금지된 해결책:**

    - 하나의 큰 **독점적 잠금(exclusive lock)**으로 캐시에 대한 모든 접근을 보호하는 것은
      허용되지 않습니다.


- **권장 구현 방안:**

    - Pthreads readers-writers locks 사용을 고려하거나,
    - 세마포어(semaphores)를 사용하여 독자-작성자(readers-writers) 솔루션을 직접 구현할 수 있습니다.
    - LRU 정책을 엄격하게 구현할 필요가 없다는 점이 다중 독자 지원에 유연성을 제공합니다.


#### 평가


- **배점:** 캐시 기능 구현에 대해 자동 채점을 통해 15점을 받습니다.

- **테스트 시 주의사항:** 모든 최신 웹 브라우저는 자체적인 캐시를 가지고 있으므로, 프록시의
  캐시를 테스트하기 전에 **브라우저의 캐시를 반드시 비활성화**해야 합니다.
