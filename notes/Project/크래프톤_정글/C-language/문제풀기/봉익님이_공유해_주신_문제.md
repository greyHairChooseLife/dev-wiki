
- File Path: bongik.c
  ```c
  #include <stdio.h>
  #include <stdlib.h>
  // 리틀 엔디언 시스템 기준
  
  int main() {
      // 문제1.
      short sArr[10] = {-1, -2, 1, 0, 3, 2, 5, 4, 7, 6};  // 2bytes size
      int* pI = (int*)sArr;                               // 4바이트로
      unsigned int result = *(pI + 1);                    // 4bytes offset
      printf("%d\n", result);  // 1 표현한 2B와 0표현한 2B를 포함한 4B를 읽는다.
                               // 즉, 0b0100 == 4
  
      // 문제2.
      int iData = *(short*)(pI + 2);  // 우선순위가 뭐지? 타입캐스팅이 빠르겠지?
      printf("%d\n", iData);          // 1
  
      // 문제3.
      /* iData = ((char*)(pI + 2)); // short type -2가 char타입으로 표현된다. */
      iData = ((char)(pI + 2));  // short type -2가 char타입으로 표현된다.
      // 0000_0000_0000_0010 ==> 1111_1111_1111_1110에서 1바이트로 줄면 1111_1110
      // 254
      printf("%d\n", iData);
  
      // 문제4.
      char cArr[2] = {1, 1};
      short* pS = (short*)cArr;
      int answer = *pS;
      printf("%d\n", answer);  // 0b0000_0001_0000_0001 ==> 257
  
      // 문제5  ppI를 사용하여 sArr[4] "0"을 출력하기
      int** ppI = &pI;                     // int로 타입캐스팅 됐다. 2B -> 4B
      printf("%d\n", **ppI /*add code*/);  // 4바이트씩 읽을텐데 이게 되는건가?
                                           // 00이 연속된 칸이 있지 않은 이상...
      return 0;
  }
  ```

  - 결과: 와장창
    ```sh
    실습$ ./bongik.out
    1
    3
    88
    257
    -65537
    ```
