# 섹션 11. 연산자


## 42. 연산자 기본 이론


- 형변환 연산자
  - 데이터 타입에 따라 크기가 다른데, 예를들어 int(4B)를 char(1B)로 바꾸면 값이 훼손될 수 있다.
    그것을 알고서도 사용해야 할 때가 있다.


- 비트연산자

  ```c
  unsigned int a = 5;   // 0b0101
  unsigned int b = 3;   // 0b0011

  printf("a & b = %u\n", a & b);   // AND: 1 (0b0001)
  printf("a | b = %u\n", a | b);   //  OR: 7 (0b0111)
  printf("a ^ b = %u\n", a ^ b);   // XOR: 6 (0b0110)
  printf("~a = %u\n", ~a);         // NOT: 4294967290 (0b11111111111111111111111111111010)
  printf("a << 1 = %u\n", a << 1); // L 시프트: 10 (0b1010)
  printf("a >> 1 = %u\n", a >> 1); // R 시프트:  2 (0b0010)
  ```

  - 비트단위로 각 AND, OR 등 연산한다.
  - `~a`가 단순히 `0b1010`이 되지 않는 이유는 **비트 NOT 연산은 변수의 전체 비트 수(예: 8, 16,
    32비트 등) 모두를 반전**하기 때문. `a`는 int형이니 4바이트다.  실제로는 0b


- 연산자 우선순위

  1. oeprand 자체가 되는것
  2. 단항연산 (sizeof(), & 주소연산자)
  3. 산술연산
  4. 관계연산(크다, 작다, 같다)
  5. 논리연산(and, or, not)
  6. 대입
  7. 나열(`,` 이것도 나름 연산자)

  ![연산자 우선순위](/home/sy/Documents/dev-wiki/notes/tmp-img/aa.png)


- 연산자 결합성

  - 우선순위 외에도 결합성 개념이 있는데, ALU는 2항 연산까지 가능하기 때문
  - 예를들어 3개 이상의 항을 더한다고 하면,
    3+7+5 => 3 + 12 => 15 (Good)
    3+7+5 => 10 + 5 => 15 (결과는 같아도 과정이 틀렸다. 컴퓨터는 이렇게 하지 않는다.)
  - 이때 임시결과는 따로 저장하지 않으면 사라지게 됨. 필요하면 따로 저장 필요




## 43. 산술 연산자


- ```
  +, -, *, /, %
  ```

- 연산의 결과로 임시결과 발생
- **정수 간 나눗셈의 결과는 반드시 정수가 되며, 소수점 이하는 절사**
  - `1/3`은 0이 된다. 즉, 몫만 남긴다.
  - `1/3`과 `1.0/3`은 다르다.





## 44. 이형자료 연산과 형승격 (Type Promotion)


- 임시결과는 피연산자 표현범위 이상의 표현이 가능해야함
  즉, char + int 의 결과는 int 타입이 된다는 것이다.

  > [!qt] int * int가 어쩔땐 int의 범위를 넘어가는 경우도 있잖아. 그럴땐 어떻게돼?
  >   󱞪 C 표준에서는 **정수 오버플로우**가 발생
  > 
  >   - **부호 없는 정수(unsigned int)**:
  >     오버플로우 시 모듈로 연산(순환, wrap around)이 일어나며, 정의된 동작
  >   - **부호 있는 정수(int)**:
  >     오버플로우는 **정의되지 않은 동작**. 즉, 결과가 예측 불가하며, 프로그램이 비정상적으로 동작
  >   
  >   - 더 큰 타입(`long`, `long long`)으로 변환해서 연산하면 오버플로우를 피할 수 있음
  >     ````c
  >     int a = 1000000;
  >     int b = 3000;
  >     int c = a * b; // int 범위 초과 → undefined behavior 가능성
  >     
  >     long long d = (long long)a * b; // 안전하게 큰 타입으로 연산
  >     ````





## 45. 0으로 나누면 안 되는 이유


- 무한 연산발생 => OS레벨에서 프로세스 중지 시켜줌
- **사용자의 입력을 절대 믿지 마라.**




## 46. 필수 실습 문제 평균값 구하기

```
/home/sy/jg/dokk-C/실습/11-46.c
```




## 47. 필수 실습 문제 시 분 초 계산하기


```
/home/sy/jg/dokk-C/실습/11-47.c
```



## 48. 단순 대입 연산자


```
<l-value> = <r-value>
```

- 'l-value'의 'l'은 Location

  Location은 메모리의 Location, 즉 주소를 뜻한다.

  즉, **주소만 넣어야 한다는 것**


- r-value는 변수 상수 모두 가능



- 대입 연산 실수 예시
  ```c
  char myList[16] = {0};
  myList = "hello";          // 에러, 
                             // 배열에 문자를 할당한게 문제가 아니라(r-value가 문제가 아니라)
                             // myList는 주소값(상수)이고 따라서 l-value에 주소가 아닌 상수를
                             // 넣은게 문제다.
  ```





## 49. 필수 실습 문제 두 변수 값 교환


```
/home/sy/jg/dokk-C/실습/11-49.c
```



## 50. 복합 대입 연산자

+=, -= 등 똑같다.


## 51. 필수 실습 문제 세 정수 총합 계산하기 (누산)


```
/home/sy/jg/dokk-C/실습/11-51.c
```


## 52. 형변환 연산자

- 형변환 => 데이터의 크기 변경 => **정보가 유실될 수 있음**
- 두 가지 타입 값들의 연산 결과는 표현의 범위가 넓은 타입



## 53. 단항 증/감 연산자

- 전위(`++number`)는 다른 언어와 똑같다.
- 후위(`number++`)는 우선순위가 최하위다. 할당(대입) 연산자 보다도.
  따라서 다음 행에 이루어지는 것과 같다.


## 54. 비트 연산자와 엔디안(Endian)


- 비트 연산자
  - 특정 영역의 값이 모두 0이 되도록 지우는 연산
  - `AND` 연산의 특징을 이용
    - `0`과 `AND` 연산을 수행하면 무조건 `0`

  ex)
  ```c
  int nData = 0x11223344;

  printf("%d\n", nData);                 //              287_454_020
  printf("%08X\n", nData & 0x00FFFF00);  // AND          0022_3300  
  printf("%08X\n", nData | 0x00FFFF00);  // OR           11FFFF44
  printf("%08X\n", nData ^ 0x00FFFF00);  // XOR          11DDCC44
  printf("%08X\n", ~nData);              // NOT          EEDDCCBB
  printf("%08X\n", nData >> 8);          // Shift Right  00112233
  printf("%08X\n", nData << 8);          // Shift Left   22334400
  ```

  - shift right 연산은 signed 요소를 살려준다.


- 엔디안
  
  - Little endian: 크기 2바이트 이상의 데이터인 경우 메모리에 저장될 때 역순으로 저장된다.
    - Intel 계열 프로세서
    - **근데 생각해보면 1바이트 짜리면 뒤집어봤자 똑같다.**
    - **그래서 unicode+16, unicode+32 이런건 2바이트 이상이니까 뒤집어진다.**


  - 예를들어 

    - 첫 번째: `0x12345678` 총 4B 크기
    - 두 번째: `0xaAbBcCdD` 총 4B 크기
    라고 할 때,

    - Big Endian
    ```
    12 34 56 78 AA BB CC DD
    ```

    - Little Endian
    ```
    78 56 34 12 dD cC bB aA
    ```
  



## 55. 필수 실습 문제 뺄셈 연산 직접 구현하기


```
/home/sy/jg/dokk-C/실습/11-55.c
```

진짜로 되는게 신기해



## 56. sizeof 연산자

- 메모리 접근에 자유도(위험)가 높은 만큼 정확한 메모리 크기를 다룰 수 있도록 돕는 연산자
- **컴파일 타임 연산자**
  - 컴파일 단계에서 계산되기 때문에 아무리 많이 써도 프로그램 성능에 영향 없음
  - 성능을 위해 조금도 아낄 필요가 없다. 오히려 적극 사용해라

- 배열의 크기를 다루기 위해 사용하는게 보통

  ```c
  int aList[16];
  printf("%ldd\n", sizeof(aList));
  printf("%ldd\n", _countof(aList)); // 얘는 개수를 세어 준다.
  ```


- 참고
  - `sizeof('A') ==> 4` 4B가 나온다.
  - `sizeof(++값) ==> 값이 변하지 않는다.` sizeof 연산자 안에서 일어난 연산은 sizeof 연산의 결과에만
    영향을 미친다.



## 57. 관계 연산자


```
>, >=, <=, <, ==, !=
```


```
- True : not 0
- False: 0
```


- **실수형에 대해 상등, 부등 연산은 하지마라, 하지마**
  - 하면 안되지 못하는것은 아니다. 즉, 실수안하게 조심해야한다.
  - ex)
    ```c
    printf("%d\n", 300 == 299.99999F);   // 1
    printf("%d\n", 300 == 299.99999);    // 0
    printf("%d\n", 300 == 299.9999F);    // 0
    printf("%d\n", 300 == 300.00001F);   // 1
    ```
    - double인 경우 좀 더 나은 것 같기도 하지만 정확히 알기 어렵다.
    - 하지말라면 하지 마

    - > [!qt] 근데 그래도 할 일이 있지 않나? 그럴 땐 어쩌지?
      >   󱞪 

   


## 58. 논리 연산자


- 결합성은 Left -> Right
- 주로 경계를 찾을 때 사용



## 59. 쇼트 서킷과 범위검사 흔한 오류 예


- 논리식(주로 조건식에서)을 빠르게 평가되는 방식으로 배치하자
  - 논리합: `A || B`, any
  - 논리곱: `A && B`, every



## 60. 조건 (3항) 연산자


- ```
  조건식 ? 항A : 항B

  (조건식) ? (항A) : (항B)
  ```

- **선택**의 결과인 '항'이 연산의 결과가 됨
- 웬만하면 조건이든 항이든 괄호로 묶자



## 61. 필수 실습 문제 합격, 불합격 판단하기

```
/home/sy/jg/dokk-C/실습/11-61.c
```



## 62. 필수 실습 문제 최댓값 구하기 - 서바이벌 방식

```
/home/sy/jg/dokk-C/실습/11-62.c
```



## 63. 필수 실습 문제 최댓값 구하기 - 토너먼트 방식

```
/home/sy/jg/dokk-C/실습/11-63.c
```


