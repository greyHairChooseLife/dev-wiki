# 디버거 사용법


**기본 형식**
```
x/[N][FMT][SIZE] ADDRESS
```
- `N`: 출력할 항목 개수 (생략 시 1)
- `FMT`: 출력 형식 (문자 하나, 생략 시 16진수)
- `SIZE`: 데이터 크기 (문자 하나, 생략 시 기본 word 크기)
- `ADDRESS`: 메모리 주소(또는 변수, 심볼 등)

---

**출력 형식(FMT)**
- `x`: 16진수(hexadecimal)
- `d`: 10진수(decimal)
- `u`: 부호 없는 10진수(unsigned decimal)
- `o`: 8진수(octal)
- `t`: 2진수(binary)
- `f`: 부동소수점(floating point)
- `a`: 주소(address)
- `c`: 문자(character)
- `s`: 문자열(string)

**데이터 크기(SIZE)**
- `b`: 바이트(byte, 1바이트)
- `h`: 하프워드(halfword, 2바이트)
- `w`: 워드(word, 4바이트)
- `g`: 자이언트(giant, 8바이트)

---

**예시**

1. 주소 0x601050에서 4개의 워드를 16진수로 출력:
   ```
   x/4xw 0x601050
   ```

2. 주소 0x601050에서 8개의 바이트를 10진수로 출력:
   ```
   x/8db 0x601050
   ```

3. 포인터 변수 `ptr`이 가리키는 곳의 문자열 출력:
   ```
   x/s ptr
   ```

4. 레지스터 `$esp`가 가리키는 곳의 16진수 4개 출력:
   ```
   x/4x $esp
   ```

5. 주소 0x400000에서 16바이트를 16진수로 출력:
   ```
   x/16xb 0x400000
   ```

---

**추가 팁**
- 주소 대신 변수, 심볼, 레지스터 등도 사용 가능
- `x`만 입력하면 이전 주소 다음 위치부터 계속 출력



---


> [!TIP]
>
> context watch에는 주요 변수들의 주소값을 보고있으면 좋다.
> 왜냐면 disasm에선 그것들을 `offset(%rbp)` 형식으로 보여주기 때문이다.
>
> 적어도 그것의 평가된 최종 주소값은 우측에 주석 따위로 보여주고 있기 때문에
> 뭘 찍어보지 않고도 눈으로 비교할 수 있다.
>
> - 예시)
> ```asm
>  ► 0x56513ded8482 <insertSortedLL+170>    movl   -0x2c(%rbp), %edx     EDX, [0x7ffd57bf0924] => 0x23
>    0x56513ded8485 <insertSortedLL+173>    movl   %edx, (%rax)          [0x56514a02fac0] <= 0x23
> ```
