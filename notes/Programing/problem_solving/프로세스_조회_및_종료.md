# 󰏢 프로세스 조회 및 종료

## 발단 및 문제 정의

1. JS로 express 테스트서버 실행중, 실수로 무한루프에 빠질뻔함. 무한 Mod+q로 간신히 웹서버 실행한 터미널을 종료함.
2. 다시 터미널 켜서 실행해보니 이미 사용중인 포트라고 함. 뭐지? 해당 포트로 로컬호스트 접속해보면 서버 잘 살아있음.
3. vim 인스턴스 내부 터미널로 실행해서 그런가 하고 다시 재현해봄. 상관없는것을 확인.
4. `btop`으로 조회하고 **프로세스 종료하려하니 관리자 권한 필요하다고 함. 왜?**
5. `sudo btop` 또는 `kill -9`로 프로세스 강제종료 시도. **꺼지긴 하는데 좀비처럼 되살아남. 왜?**


> [!bl] 탐구할 것
>
> - 실행할 땐 관리자권한 없어도 되는 프로세스가 종료할 땐 왜 그것을 필요로 하나?
> - 기본적인 express 서버가 왜 좀비처럼 되살아나나?
> - 현재 시스템에서 열려있는 포트번호는 어떻게 조회할 수 있나?



## 해결 [-]

### 실행할 땐 관리자권한 없어도 되는 프로세스가 종료할 땐 왜 그것을 필요로 하나?

- 데이터 유실 등 시스템에 영향을 미칠 수 있다고 여긴다.
- 소켓을 점유한 경우 종료에 관리자 권한이 필요하다. 데이터가 오갈수 있어서인듯?


### 기본적인 express 서버가 왜 좀비처럼 되살아나나? [-]

부모 프로세스가 자식프로세스의 종료된 상태정보를 인지해야하는데, 그렇지 못해서 좀비 프로세스가 되는 경우가 있다.

그런데 이번에 내 경우엔 달랐다. 도커 컨테이너중에 3000포트를 사용하는게 있었을 뿐이다! 이 컨테이너는 외부에 노출시키는 웹서버라서 무한 재시작을 설정해뒀던 것이다.

내가 문제되는 프로세스를 조회한 방법이 단지 grep으로 해당 포트번호를 조회한것 뿐이라 실수가 있었다.


> [!qt] 근데, 그럼 어떻게 똑같은 포트번호를 사용할 수 있었을까?
>
> 도커 서비스가 사용하는 네트워크와 문제가 된 프로세스(express웹서버)가 사용하는 네트워크가 전혀 달랐기 때문이다.
> 테스트 서버야 당연히 localhost이고, localhost는 localhost만의 독립된 네트워크 환경을 가진다. 전혀 문제가 안된다.
>
> 게다가 도커는 도커대로 별도 네트워크를 가지고 있다. 가끔 cli로 ip주소 알아내겠다고 `ipconfig`해보면 docker서비스가 실행중일 땐 도커 전용 인터페이스가 우다다 생겨있는걸 볼 수 있을 것이다.


그렇다고 문제가 해결되진 않았다. 이상한 점은:

  - 브라우저에서 `localhost:포트`로 접속해보면 잘 작동한다.
  - 새로운 터미널에서 다시 해당 포트로 서버를 실행하면 '이미 사용중인 포트'라고 한다.
  - 그런데도 `ss -tuln | grep 127.0.0.1 | grep <포트>` 으로 조회해도 해당 포트가 조회되지 않는다.


#### 원인 추측

1. 프로세스가 비정상 종료될 때 포트를 제대로 해제하지 못한 경우
2. 캐시된 네트워크 소캣 상태: `ss`같은 소켓 상태 조회 결과에 완전히 반영되지 않은 경우
3. TCP 연결이 아직도 TIME_WAIT 상태인 경우(이건 일정 일종의 대기시간)


[-] 더 파고들고싶은데, 지금 내가 놀고있는 시간이 아니다. 일단은 책임감 있게 일부터 하자!


### 현재 시스템에서 열려있는 포트번호는 어떻게 조회할 수 있나?

_더 명료하게 질문할 수 있다. 시스템의 네트워크 **소켓** 정보를 확인하는 방법은 무엇인가?_

`ss -tuln` 명령으로 조회할 수 있다.


- 출력 필드 설명
  |        Column        | 설명                                                                                                            |
  |:--------------------:|-----------------------------------------------------------------------------------------------------------------|
  |        Netid         | 소켓 유형. ex) `tcp` 또는 `udp`                                                                                 |
  |        State         | 소켓 상태. ex) `LISTEN` (연결 대기 중), `ESTABLISHED` (연결 완료 상태)                                          |
  |        Recv-Q        | 수신 대기열의 데이터 크기(바이트 단위). 아직 전송이 완료되지 않은 양.                                           |
  |        Send-Q        | 송신 대기열의 데이터 크기(바이트 단위). 아직 전송이 완료되지 않은 양.                                           |
  | Local (Address:Port) | 로컬에서 해당 소켓이 어느 ip:port로 열려있는지 표시. 즉 해당 로컬의 해당 위치와 외부 세계를 연결시켜줘야 하는것 |
  | Peer (Address:Port)  | 해당 소켓으로 연결된 외부(상대방)의 IP와 포트                                                                   |

  _(각 항목의 세부 설명)_

  1. UDP와 TCP의 차이점

     - TCP: 연결 지향형.
       - 데이터 전송 전에 연결 설정
       - 손실된 데이터 자동 재전송
       - 순서 보장
       - 웹 브라우징, 파일 전송 등 신뢰성이 중요한 곳에 사용

     - UDP: 비연결형.
       - 연결 설정 없이 전송
       - 신뢰성 보장 안 함
       - 순서 보장 안 함
       - 실시간 스트리밍, 온라인 게임, VoIP처럼 속도가 중요한 곳에 사용

  2. UDP의 `UNCONN` 상태

     - `UNCONN` = Unconnected (연결되지 않음). UDP는 연결형이 아니라 항상 `UNCONN` 상태로 표시됨. 요청이 오면 즉시 데이터 전송 후 종료.

  3. `Local Address` 표기

     - `*`: 모든 IP 주소 의미. 여러 인터페이스에서 접근 가능.
     - `127.0.0.1`: 로컬에서만 접근 가능.
     - `0.0.0.0`: 모든 IPv4 주소에서 접근 가능.
     - `[::1]`: IPv6의 로컬 주소. 로컬에서만 접근 가능.
     - 고유 IP: 특정 네트워크 인터페이스에 바인딩된 IP. 해당 네트워크에서만 접근 가능.

  4. `Peer Address`가 `*:*` 또는 `0.0.0.0:*`인 이유

     - `*:*` 및 `0.0.0.0:*`: 특정 피어와 연결되지 않은 상태. 서버가 클라이언트 요청 대기 중인 상태로, 모든 클라이언트 요청을 수락할 준비가 되어 있다는 뜻.
