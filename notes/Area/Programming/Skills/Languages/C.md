



> [!nt] 스터디 방식
>
>
> - 준비: 정해진 구간까지 수강하고 내용 재 범주화
>         강의 목차를 그대로 따르는 색인은 반드시 표시
>
> - 모임: 서로 노트정리한 내용을 스크리닝


> [!td]
>
> - [x] 1차: ~ 10강
> - [ ] 2차: ~ 15강
> - [ ] 3차: ~ 끝까지(예정)



> [!nt]
>
> - _'운영체제 아주 쉬운 세가지'_ PDF 버전은 'OSTEP' 검색하면 받을 수 있다.




## 디버거 사용법




> [!nt] 디버깅 시작하기
>
>
> 1. pwndbg-lldb <실행파일>
> 2. 소스코드는 에디터로 따로 켜두고 봐라
>
>
> > [!qt] pwndbg-lldb도 실행중인 프로세스에 붙일 수 있나? 가능하다면 iput, output등 추적하기 좋을텐데
> >   󱞪 




### 1. 중단점 설정 및 관리

| 명령어                                     | 약어       | 예시                    | 설명                         |
|--------------------------------------------|------------|-------------------------|------------------------------|
| `breakpoint set --name 함수명`             | `b 함수명` | `b main`                | 함수 진입 시 중단점 설정     |
| `breakpoint set --file 파일명 --line 라인` |            | `b me.c:47`             | 특정 파일/라인에 중단점 설정 |
| `breakpoint list`                          |            |                         | 모든 중단점 목록 출력        |
| `breakpoint delete 번호`                   |            | `breakpoint delete 1`   | 해당 번호 중단점 삭제        |
| `breakpoint delete 시작번호-끝번호`        |            | `breakpoint delete 1-5` | 구간 번호 중단점 삭제        |


### 2. 실행 제어

| 명령어     | 약어 | 예시     | 설명                                |
|------------|------|----------|-------------------------------------|
| `run`      | `r`  | `run`    | 프로그램 실행/재시작                |
| `continue` | `c`  | `c`      | 다음 중단점/종료까지 실행           |
| `next`     | `n`  | `n`      | C 코드 한 줄 실행(함수 내부 진입 X) |
| `step`     | `s`  | `s`      | C 코드 한 줄 실행(함수 내부 진입 O) |
| `stepi`    | `si` | `si`     | 어셈블리 한 명령어 실행             |
| `finish`   |      | `finish` | 현재 함수 끝까지 실행 후 복귀       |
| `kill`     |      | `kill`   | 디버깅 프로세스 강제 종료           |


### 3. 변수 및 메모리 검사

| 명령어                | 약어       | 예시                | 설명                                         |
|-----------------------|------------|---------------------|----------------------------------------------|
| `print 변수명`        | `p 변수명` | `p len`             | 변수 값 출력                                 |
| `print &변수명`       |            | `p &len`            | 변수 주소값 출력                             |
| `print *포인터`       |            | `p *ptr`            | 포인터가 가리키는 값 출력                    |
| `hexdump 주소 [길이]` |            | `hexdump &len 0x20` | 주소부터 32바이트 메모리 16진수+ASCII로 출력 |
| `telescope 주소`      |            | `telescope $rsp`    | 포인터 체이닝 구조 시각화                    |
| `vmmap`               |            | `vmmap`             | 프로세스 전체 메모리 맵 출력                 |


### 4. 컨텍스트(레지스터, 어셈블리, 프레임, 스택/스레드 정보)

| 명령어                     | 약어   | 예시                  | 설명                              |
|----------------------------|--------|-----------------------|-----------------------------------|
| `context`                  | `ctx`  |                       | 모든 컨텍스트 출력             |
| `register read`            | `regs` | `register read`       | 모든 레지스터 값 출력             |
| `register read 레지스터명` |        | `register read rip`   | 특정 레지스터 값 출력             |
| `disassemble`              |        | `disassemble`         | 현재 위치 어셈블리 코드 출력      |
| `disassemble --frame`      |        | `disassemble --frame` | 현재 프레임 전체 어셈블리 출력    |
| `frame info`               |        | `frame info`          | 현재 함수/파일/줄 정보 출력       |
| `bt`                       |        | `bt`                  | 함수 호출 스택(콜 스택) 전체 출력 |
| `thread list`              |        |                       | 모든 스레드 목록 출력             |
| `thread select 번호`       |        | `thread select 1`     | 해당 스레드로 전환                |


- `x` 명령어 사용법

  | 명령어 형식       | 예시               | 설명                                               |
  |-------------------|--------------------|----------------------------------------------------|
  | `x/개수형식 주소` | `x/4xw 0x7fffde00` | 주소부터 4개 워드(4바이트) 값을 16진수로 출력      |
  | `x/개수형식 변수` | `x/8xb buf`        | 변수(buf)의 메모리 8바이트를 16진수로 출력         |
  | `x/개수c 주소`    | `x/16c str`        | 주소(str)부터 16개 문자를 문자(char)로 출력        |
  | `x/개수d 주소`    | `x/4dw arr`        | 주소(arr)부터 4개 워드 값을 10진수로 출력          |
  | `x/s 주소`        | `x/s str`          | 주소(str)에서 시작하는 null-terminated 문자열 출력 |
  | `x/개수f 주소`    | `x/2f arr`         | 주소(arr)부터 2개 float 값을 출력                  |
  | `x 주소`          | `x 0x601050`       | 주소 한 개의 값을 기본 형식(16진수, 워드)으로 출력 |

  - 주요 옵션 설명

    - 주소/변수: 메모리 주소 또는 변수명 사용 가능
    - `/개수형식` : 출력할 개수와 데이터 형식 지정 (예: `4xw` → 4개, 16진수, 워드 단위)
      - 개수: 출력할 항목 수 (생략 시 1)
      - 형식:  
        - `x` : 16진수(hex)
        - `d` : 10진수(decimal)
        - `u` : 부호 없는 10진수(unsigned)
        - `c` : 문자(char)
        - `f` : 부동소수점(float)
        - `s` : 문자열(string)
      - 단위:  
        - `b` : 바이트(byte)
        - `h` : 하프워드(2바이트)
        - `w` : 워드(4바이트)
        - `g` : giant word(8바이트)

  - 활용 예시

    - 배열/버퍼의 메모리 상태를 직접 확인하고 싶을 때
    - 포인터가 가리키는 실제 데이터를 보고 싶을 때
    - 문자열, 구조체, float 등 다양한 형식으로 메모리 해석 가능


## etc

- 전가산기(반가산기)

  C: Carry. 올림을 활용하는 것
  S: 올림을 제외한 연산의 결과값

- [ ] 그림 추가






## 강의 목차에 따른 내용 정리

### 섹션 10. 표준 입/출력

33. 콘솔(Console)이란 무엇일까?

  - kernel 영역에 입출력 장치와 연결된 영역이 있다.
  - 이 영역에 접근할 수 있도록 user 영역에 추상화된 계층을 제공하는데, 그것이 File이다.
  - 결국 이 File에 Read / Write / eXecute 하는게 프로세스다.

  - 예시,

    하드웨어 입력장치에 입력(키보드 누르기)
    -> interrupt 발생
    -> 커널 영역의 '어딘가'에 입력
    -> 입출력 버퍼(메모리)
    -> (출력 등 관련된 놈들이 read해서 이용)

---

34. 문자 입/출력

```c
/* buffered I/O */
ch = getchar(); /* I/O 버퍼(que)에서 최근 값 하나 가져와서 'ch' 메모리에 저장 */
putchar(ch);    /* 'ch' 메모리에서 값을 가져다가 I/O 버퍼에 넣기 */
putchar('Z');   /* 원시값 하나를 I/O 버퍼에 넣기 */
```

```c
/* Non-buffered I/O */
/* 하드웨어 입력을 버퍼 거치지 않고 걍 가져와버림 */
_getch()
_getche()
```


---


35. 문자열 입/출력

- 문자열은 가변길이
- 문자열의 끝은 null로 끝나야한다.




36. gets() 함수와 보안 결함 (feat. 시큐어 코딩)
37. 형식 문자와 이스케이프 시퀀스
38. 실수 출력
39. 문자, 정수 입력과 개행문자 제거
40. 형식 문자 기반 문자열 입력
41. 필수 실습 문제 나이와 이름 입/출력 하기


### 섹션 11. 연산자

42. 연산자 기본 이론
43. 산술 연산자
44. 이형자료 연산과 형승격
45. 0으로 나누면 안 되는 이유
46. 필수 실습 문제 평균값 구하기
47. 필수 실습 문제 시 분 초 계산하기
48. 단순 대입 연산자
49. 필수 실습 문제 두 변수 값 교환
50. 복합 대입 연산자
51. 필수 실습 문제 세 정수 총합 계산하기 (누산)
52. 형변환 연산자
53. 단항 증/감 연산자
54. 비트 연산자와 엔디안(Endian)
55. 필수 실습 문제 뺄셈 연산 직접 구현하기
56. sizeof 연산자
57. 관계 연산자
58. 논리 연산자
59. 쇼트 서킷과 범위검사 흔한 오류 예
60. 조건 (3항) 연산자
61. 필수 실습 문제 합격, 불합격 판단하기
62. 필수 실습 문제 최댓값 구하기 - 서바이벌 방식
63. 필수 실습 문제 최댓값 구하기 - 토너먼트 방식

### 섹션 12. 기본 제어문

64. if문과 스코프
65. 필수 실습 문제 최댓값 구하기 - if문 버전
66. 필수 실습 문제 버스요금 계산
67. if else문
68. if else문 중첩 (분류와 선택)
69. 필수 실습 문제 연령별 버스요금 계산
70. 다중 if문
71. 중첩 스코프와 식별자 검색 순서
72. switch-case문
73. 무조건 goto문

### 섹션 13. 반복문

74. 조건 기반 반복 while과 무한 루프
75. 필수 실습 문제 한 줄에 '*' 출력
76. 계수 기반 반복 for
77. 필수 실습 문제 총합 계산하기
78. 반복문 중첩
79. 필수 실습 문제 국룰 * 출력 놀이
80. 필수 실습 문제 '*' 출력 놀이 응용
81. do while문
82. break와 continue

### 섹션 14. 배열과 프로그래밍 기법 (Part 3 C언어 수준향상)

83. 배열의 기본 문법
84. 필수 실습 문제 배열에서 최댓값 찾기
85. 필수 실습 문제 버블정렬
86. 필수 실습 문제 선택정렬
87. 다차원 배열
88. 필수 실습 문제 교차와 달팽이 숙제
89. 고급 기법 Lookup 배열

### 섹션 15. 함수에 대한 기본 이론

90. 사용자 정의 함수 기초 이론
91. 기초적인 함수 설계 원칙
92. 필수 실습 문제 최댓값을 반환하는 함수
93. 이벤트 루프 구현
94. 원형 선언과 분할 컴파일
95. 전역변수와 식별자 검색 순서


## 자료형

- C언어에서 자료형은 **일정 길이의 메모리에 저장된 정보를 해석하는 방법**
- 정보(자료)는 결국 숫자
- 정보(자료)는 변수와 상수 두 종료가 있음
- C언어의 **변수는 메모리를 사용하기 위한 문법**으로 이해할 수 있음

  - 정수형(부호유무, 크기)
    char 데이터타입이 포함되어있는데, 컴퓨터에 저장되는 데이터로는 정수이기 때문에 정수형이라고
    한다. 물론 그걸 ascii문자로 해석해서 화면에 보여주긴 하겠지만.
  - 실수형(크기)
  - 유도형(*, [], 구조체, 공용체)
  - 함수형
  - 무치형(void)

### 정수형

- 컴퓨터의 연산(2진수 연산)

  - 곱셈
    1. 방법 1: 여러번 더하기
    2. 방법 2: `(*2 ==)` 왼쪽 shift 연산 + padding(우측)

  - 나눗셈
    1. 방법 1: 여러번 빼기
    2. 방법 2: `(/2 ==)`오른쪽 shift 연산 + padding(좌측) + 오른쪽 절삭

### 실수형

_부동소수점 오차를 유념하고 유효범위를 고려해 프로그램을 작성한다._

- float : 소수점 이하  6자리 유효 (해상도가 낮아서 잘 안쓴다.)
- double: 소수점 이하 15자리 유효
  - long double은 지원하지 않는 시스템 또는 컴파일러도 있다.





## QnA


> [!qt] 어떤 데이터는 1B로 저장된다. 근데 그 값이 저장된 메모리에 주소값도 있어야해서 어딘가 32b 혹은 64b가 주소값을 위해 저장되어야 한다. 이게 앞뒤가 안맞지 않나?
>   󱞪 원래 그렇다. 모든 메모리를 1B짜리 데이터로 사용하진 않는다.


`인코딩(encoding)`이란, 데이터를 특정한 규칙에 따라 다른 형식(특히, 0과 1의 비트열)으로 변환하는
과정을 의미합니다.


> [!qt] 컴파일링 과정 -> 의역의 가능성이 있다.
>   󱞪 



