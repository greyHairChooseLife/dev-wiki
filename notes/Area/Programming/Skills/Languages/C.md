



> [!nt] 스터디 방식
>
>
> - 준비: 정해진 구간까지 수강하고 내용 재 범주화
>         강의 목차를 그대로 따르는 색인은 반드시 표시
>
> - 모임: 서로 노트정리한 내용을 스크리닝


> [!td]
>
> - [x] 1차: ~ 10강
> - [ ] 2차: ~ 15강
> - [ ] 3차: ~ 끝까지(예정)



> [!nt]
>
> - _'운영체제 아주 쉬운 세가지'_ PDF 버전은 'OSTEP' 검색하면 받을 수 있다.




## 디버거 사용법




> [!nt] 디버깅 시작하기
>
>
> 1. pwndbg-lldb <실행파일>
> 2. 소스코드는 에디터로 따로 켜두고 봐라
>
>
> > [!qt] pwndbg-lldb도 실행중인 프로세스에 붙일 수 있나? 가능하다면 iput, output등 추적하기 좋을텐데
> >   󱞪 




### 1. 중단점 설정 및 관리

| 명령어                                     | 약어       | 예시                    | 설명                         |
|--------------------------------------------|------------|-------------------------|------------------------------|
| `breakpoint set --name 함수명`             | `b 함수명` | `b main`                | 함수 진입 시 중단점 설정     |
| `breakpoint set --file 파일명 --line 라인` |            | `b me.c:47`             | 특정 파일/라인에 중단점 설정 |
| `breakpoint set --line 라인`               |            | `b -l 21`               | 특정 라인 중단점             |
| `breakpoint list`                          |            |                         | 모든 중단점 목록 출력        |
| `breakpoint delete 번호`                   |            | `breakpoint delete 1`   | 해당 번호 중단점 삭제        |
| `breakpoint delete 시작번호-끝번호`        |            | `breakpoint delete 1-5` | 구간 번호 중단점 삭제        |


### 2. 실행 제어

| 명령어     | 약어 | 예시     | 설명                                |
|------------|------|----------|-------------------------------------|
| `run`      | `r`  | `run`    | 프로그램 실행/재시작                |
| `continue` | `c`  | `c`      | 다음 중단점/종료까지 실행           |
| `next`     | `n`  | `n`      | C 코드 한 줄 실행(함수 내부 진입 X) |
| `step`     | `s`  | `s`      | C 코드 한 줄 실행(함수 내부 진입 O) |
| `stepi`    | `si` | `si`     | 어셈블리 한 명령어 실행             |
| `finish`   |      | `finish` | 현재 함수 끝까지 실행 후 복귀       |
| `kill`     |      | `kill`   | 디버깅 프로세스 강제 종료           |


### 3. 변수 및 메모리 검사

| 명령어                | 약어       | 예시                | 설명                                         |
|-----------------------|------------|---------------------|----------------------------------------------|
| `print 변수명`        | `p 변수명` | `p len`             | 변수 값 출력                                 |
| `print &변수명`       |            | `p &len`            | 변수 주소값 출력                             |
| `print *포인터`       |            | `p *ptr`            | 포인터가 가리키는 값 출력                    |
| `hexdump 주소 [길이]` |            | `hexdump &len 0x20` | 주소부터 32바이트 메모리 16진수+ASCII로 출력 |
| `telescope 주소`      |            | `telescope $rsp`    | 포인터 체이닝 구조 시각화                    |
| `vmmap`               |            | `vmmap`             | 프로세스 전체 메모리 맵 출력                 |


### 4. 컨텍스트(레지스터, 어셈블리, 프레임, 스택/스레드 정보)

| 명령어                     | 약어   | 예시                  | 설명                              |
|----------------------------|--------|-----------------------|-----------------------------------|
| `context`                  | `ctx`  |                       | 모든 컨텍스트 출력             |
| `register read`            | `regs` | `register read`       | 모든 레지스터 값 출력             |
| `register read 레지스터명` |        | `register read rip`   | 특정 레지스터 값 출력             |
| `disassemble`              |        | `disassemble`         | 현재 위치 어셈블리 코드 출력      |
| `disassemble --frame`      |        | `disassemble --frame` | 현재 프레임 전체 어셈블리 출력    |
| `frame info`               |        | `frame info`          | 현재 함수/파일/줄 정보 출력       |
| `bt`                       |        | `bt`                  | 함수 호출 스택(콜 스택) 전체 출력 |
| `thread list`              |        |                       | 모든 스레드 목록 출력             |
| `thread select 번호`       |        | `thread select 1`     | 해당 스레드로 전환                |


- `x` 명령어 사용법

  | 명령어 형식       | 예시               | 설명                                               |
  |-------------------|--------------------|----------------------------------------------------|
  | `x/개수형식 주소` | `x/4xw 0x7fffde00` | 주소부터 4개 워드(4바이트) 값을 16진수로 출력      |
  | `x/개수형식 변수` | `x/8xb buf`        | 변수(buf)의 메모리 8바이트를 16진수로 출력         |
  | `x/개수c 주소`    | `x/16c str`        | 주소(str)부터 16개 문자를 문자(char)로 출력        |
  | `x/개수d 주소`    | `x/4dw arr`        | 주소(arr)부터 4개 워드 값을 10진수로 출력          |
  | `x/s 주소`        | `x/s str`          | 주소(str)에서 시작하는 null-terminated 문자열 출력 |
  | `x/개수f 주소`    | `x/2f arr`         | 주소(arr)부터 2개 float 값을 출력                  |
  | `x 주소`          | `x 0x601050`       | 주소 한 개의 값을 기본 형식(16진수, 워드)으로 출력 |

  - 주요 옵션 설명

    - 주소/변수: 메모리 주소 또는 변수명 사용 가능
    - `/개수형식` : 출력할 개수와 데이터 형식 지정 (예: `4xw` → 4개, 16진수, 워드 단위)
      - 개수: 출력할 항목 수 (생략 시 1)
      - 형식:  
        - `x` : 16진수(hex)
        - `d` : 10진수(decimal)
        - `u` : 부호 없는 10진수(unsigned)
        - `c` : 문자(char)
        - `f` : 부동소수점(float)
        - `s` : 문자열(string)
      - 단위:  
        - `b` : 바이트(byte)
        - `h` : 하프워드(2바이트)
        - `w` : 워드(4바이트)
        - `g` : giant word(8바이트)

  - 활용 예시

    - 배열/버퍼의 메모리 상태를 직접 확인하고 싶을 때
    - 포인터가 가리키는 실제 데이터를 보고 싶을 때
    - 문자열, 구조체, float 등 다양한 형식으로 메모리 해석 가능


## etc

- 전가산기(반가산기)

  C: Carry. 올림을 활용하는 것
  S: 올림을 제외한 연산의 결과값

- [ ] 그림 추가






## 강의 목차에 따른 내용 정리

### 섹션 10. 표준 입/출력

33. 콘솔(Console)이란 무엇일까?

  - kernel 영역에 입출력 장치와 연결된 영역이 있다.
  - 이 영역에 접근할 수 있도록 user 영역에 추상화된 계층을 제공하는데, 그것이 File이다.
  - 결국 이 File에 Read / Write / eXecute 하는게 프로세스다.

  - 예시,

    하드웨어 입력장치에 입력(키보드 누르기)
    -> interrupt 발생
    -> 커널 영역의 '어딘가'에 입력
    -> 입출력 버퍼(메모리)
    -> (출력 등 관련된 놈들이 read해서 이용)

---

34. 문자 입/출력

```c
/* buffered I/O */
ch = getchar(); /* I/O 버퍼(que)에서 최근 값 하나 가져와서 'ch' 메모리에 저장 */
putchar(ch);    /* 'ch' 메모리에서 값을 가져다가 I/O 버퍼에 넣기 */
putchar('Z');   /* 원시값 하나를 I/O 버퍼에 넣기 */
```

```c
/* Non-buffered I/O */
/* 하드웨어 입력을 버퍼 거치지 않고 걍 가져와버림 */
_getch()
_getche()
```


---


35. 문자열 입/출력

- 문자열은 0x00로 끝난다.


---


36. gets() 함수와 보안 결함 (feat. 시큐어 코딩)

- ~시큐어코딩 시작부터 해라~
- `gets(<주소>)`는 경계를 벗어난 쓰기를 수행할 수 있다. => 버퍼 오버플로우
  - `gets_s(<주소>, <길이>)`로 개선되었다. `<길이>`만큼 이후의 입력값은 버리는 것
  - `fgets(<주소>, <길이>, stdin)` linux, mac에서 사용

---


37. 형식 문자와 이스케이프 시퀀스

- 메모리에 입력된 것은 단순한 2진수
- print할 때 그 값을 어떤 형식으로 출력할지 정해줘야함
- 일부 특수문자를 위한 escape가 있음


---

38. 실수 출력

```c
/* F는 float */
pritnf("%f", 123.456F);  // float

/* double을 실수형식으로 출력 */
pritnf("%f", 123.456);   // double
pritnf("%.2f", 123.456);   // double 소수점 아래 몇 2번째 자리까지 표현
pritnf("%lf", 123.456F); // long double
pritnf("%g", 123.456F);  // long double


pritnf("%자리수.자리수", <실수>);
```


- 정수부에 자리수를 맞추서 표현하는 법
```c
pritnf("%05d", 3);   // 00003 출력된다.
```


---


39. 문자, 정수 입력과 개행문자 제거


- 기본적인 문자 입력

  ```c
  char ch = 0;             // ch라는 이름(심볼)의 메모리를 사용할거고, 거기다 0을 할당해라
  scanf_s("%c", &ch, 1);   // ch라는 이름(심볼)에 맵핑된 주소 위치에 character를 입력할거고, 1개 입력한다
  ```


  > [!nt] scanf_s는 C99 표준이 아니다.
  >
  > ```md
  > **Diagnosis:**  
  > The error occurs because `scanf_s` is not a standard C function in ISO C99. It is a
  > Microsoft-specific extension. On Linux and with standard C, you should use `scanf` instead. Also,
  > when reading a character, you should pass the address of the variable.
  > 
  > **Pseudocode plan:**
  > - Replace `scanf_s` with `scanf`.
  > - Ensure you pass the address of the variable (e.g., `&ch`).
  > - If `ch` is an array, ensure the format string and arguments are correct.
  > ```



- 입력이 들어오면 '개행문자'까지 I/O 버퍼에 들어온다.

  ```c
      char ch[4] = {0};
      scanf("%4c", ch);   // ban 입력
  ```

  - ban세개만 입력하고 엔터키까지 쳐서 `\n`(`ASCII 0x0a`)이 입력된 모습이다.

  ```hexdump
  pwndbg-lldb> hexdump &ch 8
  +0000 0x7ffc9cb0ed24  62 61 6e 0a 00 a4 7e 03                           │ban...~.│        │
  ```


  - 그런데 입력을 만약 두번 받는다면, 첫번째 입력의 개행문자 때문에 두번째 입력은 곧바로 \n가
    stdin으로 들어온것으로 인식한다. 같은 I/O 버퍼를 쓰니까. 그래서 아래처럼 마지막 하나를
    없애줘야한다.

    `%*c`를 활용한다.

    ```c
        int age = 0;
        /* scanf("%d", age);      이렇게 하면 안되고 */   
        scanf("%d%*c", age);      // %*c로 메모리에서 char 하나 버려준다.

        char name[32] = {0};
        fgets(name, sizeof(name), stdin);
    ```




---


40. 형식 문자 기반 문자열 입력


---


41. (필수 실습 문제) 나이와 이름 입/출력 하기


```
/home/sy/jg/dokk-C/실습/10-41.c
```



### 섹션 11. 연산자


42. 연산자 기본 이론


- 형변환 연산자
  - 데이터 타입에 따라 크기가 다른데, 예를들어 int(4B)를 char(1B)로 바꾸면 값이 훼손될 수 있다.
    그것을 알고서도 사용해야 할 때가 있다.


- 비트연산자

  ```c
  unsigned int a = 5;   // 0b0101
  unsigned int b = 3;   // 0b0011

  printf("a & b = %u\n", a & b);   // AND: 1 (0b0001)
  printf("a | b = %u\n", a | b);   //  OR: 7 (0b0111)
  printf("a ^ b = %u\n", a ^ b);   // XOR: 6 (0b0110)
  printf("~a = %u\n", ~a);         // NOT: 4294967290 (0b11111111111111111111111111111010)
  printf("a << 1 = %u\n", a << 1); // L 시프트: 10 (0b1010)
  printf("a >> 1 = %u\n", a >> 1); // R 시프트:  2 (0b0010)
  ```

  - 비트단위로 각 AND, OR 등 연산한다.
  - `~a`가 단순히 `0b1010`이 되지 않는 이유는 **비트 NOT 연산은 변수의 전체 비트 수(예: 8, 16,
    32비트 등) 모두를 반전**하기 때문. `a`는 int형이니 4바이트다.  실제로는 0b


- 연산자 우선순위

  1. oeprand 자체가 되는것
  2. 단항연산 (sizeof(), & 주소연산자)
  3. 산술연산
  4. 관계연산(크다, 작다, 같다)
  5. 논리연산(and, or, not)
  6. 대입
  7. 나열(`,` 이것도 나름 연산자)

  ![연산자 우선순위](/home/sy/Documents/dev-wiki/notes/tmp-img/aa.png)


- 연산자 결합성

  - 우선순위 외에도 결합성 개념이 있는데, ALU는 2항 연산까지 가능하기 때문
  - 예를들어 3개 이상의 항을 더한다고 하면,
    3+7+5 => 3 + 12 => 15 (Good)
    3+7+5 => 10 + 5 => 15 (결과는 같아도 과정이 틀렸다. 컴퓨터는 이렇게 하지 않는다.)
  - 이때 임시결과는 따로 저장하지 않으면 사라지게 됨. 필요하면 따로 저장 필요



---

43. 산술 연산자


- ```
  +, -, *, /, %
  ```

- 연산의 결과로 임시결과 발생
- **정수 간 나눗셈의 결과는 반드시 정수가 되며, 소수점 이하는 절사**
  - `1/3`은 0이 된다. 즉, 몫만 남긴다.
  - `1/3`과 `1.0/3`은 다르다.



---


44. 이형자료 연산과 형승격 (Type Promotion)


- 임시결과는 피연산자 표현범위 이상의 표현이 가능해야함
  즉, char + int 의 결과는 int 타입이 된다는 것이다.

  > [!qt] int * int가 어쩔땐 int의 범위를 넘어가는 경우도 있잖아. 그럴땐 어떻게돼?
  >   󱞪 C 표준에서는 **정수 오버플로우**가 발생
  > 
  >   - **부호 없는 정수(unsigned int)**:
  >     오버플로우 시 모듈로 연산(순환, wrap around)이 일어나며, 정의된 동작
  >   - **부호 있는 정수(int)**:
  >     오버플로우는 **정의되지 않은 동작**. 즉, 결과가 예측 불가하며, 프로그램이 비정상적으로 동작
  >   
  >   - 더 큰 타입(`long`, `long long`)으로 변환해서 연산하면 오버플로우를 피할 수 있음
  >     ````c
  >     int a = 1000000;
  >     int b = 3000;
  >     int c = a * b; // int 범위 초과 → undefined behavior 가능성
  >     
  >     long long d = (long long)a * b; // 안전하게 큰 타입으로 연산
  >     ````




---

45. 0으로 나누면 안 되는 이유


- 무한 연산발생 => OS레벨에서 프로세스 중지 시켜줌
- **사용자의 입력을 절대 믿지 마라.**



---

46. 필수 실습 문제 평균값 구하기

```
/home/sy/jg/dokk-C/실습/11-46.c
```


---


47. 필수 실습 문제 시 분 초 계산하기


```
/home/sy/jg/dokk-C/실습/11-47.c
```


---

48. 단순 대입 연산자


```
<l-value> = <r-value>
```

- 'l-value'의 'l'은 Location

  Location은 메모리의 Location, 즉 주소를 뜻한다.

  즉, **주소만 넣어야 한다는 것**


- r-value는 변수 상수 모두 가능



- 대입 연산 실수 예시
  ```c
  char myList[16] = {0};
  myList = "hello";          // 에러, 
                             // 배열에 문자를 할당한게 문제가 아니라(r-value가 문제가 아니라)
                             // myList는 주소값(상수)이고 따라서 l-value에 주소가 아닌 상수를
                             // 넣은게 문제다.
  ```




---

49. 필수 실습 문제 두 변수 값 교환


```
/home/sy/jg/dokk-C/실습/11-49.c
```


---

50. 복합 대입 연산자

+=, -= 등 똑같다.

---

51. 필수 실습 문제 세 정수 총합 계산하기 (누산)


```
/home/sy/jg/dokk-C/실습/11-51.c
```

---

52. 형변환 연산자

- 형변환 => 데이터의 크기 변경 => **정보가 유실될 수 있음**
- 두 가지 타입 값들의 연산 결과는 표현의 범위가 넓은 타입


---

53. 단항 증/감 연산자

- 전위(`++number`)는 다른 언어와 똑같다.
- 후위(`number++`)는 우선순위가 최하위다. 할당(대입) 연산자 보다도.
  따라서 다음 행에 이루어지는 것과 같다.

---

54. 비트 연산자와 엔디안(Endian)


- 비트 연산자
  - 특정 영역의 값이 모두 0이 되도록 지우는 연산
  - `AND` 연산의 특징을 이용
    - `0`과 `AND` 연산을 수행하면 무조건 `0`

  ex)
  ```c
  int nData = 0x11223344;

  printf("%d\n", nData);                 //              287_454_020
  printf("%08X\n", nData & 0x00FFFF00);  // AND          0022_3300  
  printf("%08X\n", nData | 0x00FFFF00);  // OR           11FFFF44
  printf("%08X\n", nData ^ 0x00FFFF00);  // XOR          11DDCC44
  printf("%08X\n", ~nData);              // NOT          EEDDCCBB
  printf("%08X\n", nData >> 8);          // Shift Right  00112233
  printf("%08X\n", nData << 8);          // Shift Left   22334400
  ```


- 엔디안
  
  - Little endian: 크기 2바이트 이상의 데이터인 경우 메모리에 저장될 때 역순으로 저장된다.
    - Intel 계열 프로세서


  - 예를들어 

    - 첫 번째: `0x12345678` 총 4B 크기
    - 두 번째: `0xaAbBcCdD` 총 4B 크기
    라고 할 때,

    - Big Endian
    ```
    12 34 56 78 AA BB CC DD
    ```

    - Little Endian
    ```
    78 56 34 12 dD cC bB aA
    ```
  


---

55. 필수 실습 문제 뺄셈 연산 직접 구현하기


```
/home/sy/jg/dokk-C/실습/11-55.c
```

진짜로 되는게 신기해


---

56. sizeof 연산자

- 메모리 접근에 자유도(위험)가 높은 만큼 정확한 메모리 크기를 다룰 수 있도록 돕는 연산자
- 컴파일 타임 연산자
  - 컴파일 단계에서 계산되기 때문에 아무리 많이 써도 프로그램 성능에 영향 없음
  - 성능을 위해 조금도 아낄 필요가 없다. 오히려 적극 사용해라

- 배열의 크기를 다루기 위해 사용하는게 보통

  ```c
  int aList[16];
  printf("%ldd\n", sizeof(aList));
  printf("%ldd\n", _countof(aList)); // 얘는 개수를 세어 준다.
  ```


- 참고
  - `sizeof('A') ==> 4` 4B가 나온다.
  - `sizeof(++값) ==> 값이 변하지 않는다.` sizeof 연산자 안에서 일어난 연산은 sizeof 연산의 결과에만
    영향을 미친다.


---

57. 관계 연산자


```
>, >=, <=, <, ==, !=
```


```
- True : not 0
- False: 0
```


- **실수형에 대해 상등, 부등 연산은 하지마라, 하지마**
  - 하면 안되지 못하는것은 아니다. 즉, 실수안하게 조심해야한다.
  - ex)
    ```c
    printf("%d\n", 300 == 299.99999F);   // 1
    printf("%d\n", 300 == 299.99999);    // 0
    printf("%d\n", 300 == 299.9999F);    // 0
    printf("%d\n", 300 == 300.00001F);   // 1
    ```
    - double인 경우 좀 더 나은 것 같기도 하지만 정확히 알기 어렵다.
    - 하지말라면 하지 마

   

---

58. 논리 연산자


- 결합성은 Left -> Right
- 주로 경계를 찾을 때 사용


---

59. 쇼트 서킷과 범위검사 흔한 오류 예

- 논리식(주로 조건식에서)을 빠르게 평가되는 방식으로 배치하자
  - 논리합: `A || B`, any
  - 논리곱: `A && B`, every


---

60. 조건 (3항) 연산자


- ```
  조건식 ? 항A : 항B

  (조건식) ? (항A) : (항B)
  ```

- **선택**의 결과인 '항'이 연산의 결과가 됨
- 웬만하면 조건이든 항이든 괄호로 묶자


---

61. 필수 실습 문제 합격, 불합격 판단하기

```
/home/sy/jg/dokk-C/실습/11-61.c
```


---

62. 필수 실습 문제 최댓값 구하기 - 서바이벌 방식

```
/home/sy/jg/dokk-C/실습/11-62.c
```


---

63. 필수 실습 문제 최댓값 구하기 - 토너먼트 방식

```
/home/sy/jg/dokk-C/실습/11-63.c
```



### 섹션 12. 기본 제어문

64. if문과 스코프

- 실행 흐름을 제어한다.


---

65. 필수 실습 문제 최댓값 구하기 - if문 버전

```
/home/sy/jg/dokk-C/실습/12-65.c
```

---

66. 필수 실습 문제 버스요금 계산

```
/home/sy/jg/dokk-C/실습/12-66.c
```

---

67. if else문

- 2분할: 조건을 만족하는 것과 그 외


---

68. if else문 중첩 (분류와 선택)

- 2분할의 중첩: 대분류 - 중분류 - n분류 - 마지막 분류


---

69. 필수 실습 문제 연령별 버스요금 계산

```
/home/sy/jg/dokk-C/실습/12-69.c
```


---

70. 다중 if문

- short circuit과 같다.


---

71. 중첩 스코프와 식별자 검색 순서


- 변수(식별자)의 접근 가능 범위는 선언된 스코프로 제한 됨
  - Stack 영역에 (%rsp)가 다시 증가되니까 당연하지
  - 근데 함수 스코프가 아닌, **제어문의 스코프도 해당**


- 동일한 식별자의 경우 최근 식별자를 가리키게 됨
  - 그렇다고 **순차적 실행을 거스르진 않는다.**



---

72. switch-case문


```c
switch (<something>):{
  case <A>:  /* something == A 상등 연산으로 비교한다. */
    ...
    break;   /* 조건 만족 시 탈출을 원하면 직접 해줘야한다. */

  case <B>:  /* something == B 상등 연산으로 비교한다. */
    ...
    break;

  default:   /* 기본값 */
    ...
}


```



---

73. 무조건 goto문

- 비추

- 조건이 있는 경우엔 경우에 따라



### 섹션 13. 반복문

74. 조건 기반 반복 while과 무한 루프

- 조건을 만족하는 동안 계속


---

75. 필수 실습 문제 한 줄에 '*' 출력

```
/home/sy/jg/dokk-C/실습/13-75.c
```

---

76. 계수 기반 반복 for

- 계수는 반복문 스코프 내에서 생성해 사용하자.
- 조건이 아닌 계수를 활용한 반복은 `for (...)`가 가독성이 좋다.



---

77. 필수 실습 문제 총합 계산하기

```
/home/sy/jg/dokk-C/실습/13-77.c
```


---

78. 반복문 중첩

- 두번쓴다. 그렇다.


---

79. 필수 실습 문제 국룰 * 출력 놀이

```
/home/sy/jg/dokk-C/실습/13-79.c
```


---

80. 필수 실습 문제 '*' 출력 놀이 응용

```
/home/sy/jg/dokk-C/실습/13-80.c
```


---

81. do while문


- 무조건 한번은 실행
  - 기계어로 인코딩 되면 작동 방식은 똑같다.

- 코드도 문서다. 의도와 맥락을 명확하게 보여주는 문법으로 사용한다.



---

82. break와 continue


- **제어문이다.**

- `break`
  - 조건 따지지 않고 즉시 **현재 스코프**를 벗어난다.

- `continue`
  - 현재 반복만 즉시 건너뜀
  - _"안쓰면 더 단순하고 좋은 코드라고 생각한다."_



### 섹션 14. 배열과 프로그래밍 기법 (Part 3 C언어 수준향상)

83. 배열의 기본 문법

- **배열의 이름**은 0번 요소의 메모리 주소에 대한 식별자이며 **상수**(l-value가 아니다)

  - 문자열은 이름이 없는 문자 배열


---

84. 필수 실습 문제 배열에서 최댓값 찾기

```
/home/sy/jg/dokk-C/실습/14-84.c
```


---

85. 필수 실습 문제 버블정렬

```
/home/sy/jg/dokk-C/실습/14-85.c
```


---

86. 필수 실습 문제 선택정렬

```
/home/sy/jg/dokk-C/실습/14-86.c
```


---

87. 다차원 배열

```
/home/sy/jg/dokk-C/실습/14-87.c
```


---

88. 필수 실습 문제 교차와 달팽이 숙제

```
/home/sy/jg/dokk-C/실습/14-88.c
```


---

89. **고급 기법 Lookup 배열**


- 데이터를 검색 혹은 참조하기 위해 사용하는 배열

  - 조건문을 쓸 일이 없어진다.(성능 굿)
  - 유지보수성이 좋아진다.
  - 사용자 입력 유효성 확인을 잘 해야한다.




### 섹션 15. 함수에 대한 기본 이론

90. 사용자 정의 함수 기초 이론


- main 함수는 entry point


---

91. 기초적인 함수 설계 원칙


- **재사용 가능한 단위 코드는 함수로 구현(DRY 원칙)**
  - 유지보수성

- **UI와 기능은 반드시 분리**


---

92. 필수 실습 문제 최댓값을 반환하는 함수

```
/home/sy/jg/dokk-C/실습/14-92.c
```


---

93. 이벤트 루프 구현

- 메뉴 선택하면 해당 기능을 수행하는 것의 반복
  - 보통 프로그램이(특히 GUI가 있으면) 대부분의 프로그램이 채택하는 구조
  - 사용자 인터페이스 출력 및 사용자 입력을 반복하는 구조

- 구조
  ```c
  while ((nMenu = PrintMenu()) != 0){
    if (nMenu == 1) {
      //something
    }
    else if (nMenu == 2) {
      //something else
    }
  }
  ```

  
- 프로세스 "응답없음"이 나타는게 이런 이벤트 루프 도중 사용자 입력대기로 돌아가지 못하고 있는
  상태다.


---

94. 원형 선언과 분할 컴파일


- 함수 원형
  - 다른 말로 **함수 시그니처**
  - 선언과 정의를 분리하는 것
  - 컴파일러에게 함수의 존재를 알리기 위해 코드 상단에 기술
  - 원형만 선언할 때는 매개변수 이름을 생략 가능


- 분할 컴파일
  - 하나의 프로젝트에 여러 소스코드 파일(`.c`)을 사용하는 경우 각각을 개별로 컴파일 한다.
  - 변수나 함수 선언과 정의가 (다른 파일로) 분리될 수 있음
  - 이때 Link 오류에 주의해야함


- 예시
  > 1. **파일 구조 예시**
  >
  >      ```sh
  >      main.c
  >      foo.c
  >      foo.h
  >      ```
  >
  >      - `foo.h` : 함수 선언(시그니처)만 작성
  >      - `foo.c` : 함수 정의(구현)
  >      - `main.c` : `main()` 함수, `#include "foo.h"`
  >
  >
  >   2. **함수 시그니처(선언) 위치**
  >
  >      - main 함수가 있는 파일에는  `#include "foo.h"`로 함수 선언만 포함하면 됩니다.
  >      - 함수의 정의(구현)는 별도 `.c` 파일(예: `foo.c`)에 작성합니다.
  >
  >
  >   3. **컴파일 명령어 예시**
  >
  >      각 소스 파일을 개별적으로 컴파일하여 오브젝트 파일(`.o`)을 만든 뒤 링커로 합칩니다.
  >
  >      ```sh
  >      gcc -c main.c   # main.o 생성
  >      gcc -c foo.c    # foo.o 생성
  >      gcc main.o foo.o -o myprog   # 링크하여 실행파일 생성
  >      ```
  >
  >      또는 한 줄로:
  >      ```sh
  >      gcc main.c foo.c -o myprog
  >      ```


---

95. 전역변수와 식별자 검색 순서

- 함수 스코프 바깥에 선언하는 변수

- 웬만하면 쓰지마라
  - 정말정말정말정말 필요할때만 사용해라
  - `g_<name>`처럼 prefix 달아줘라, 쫌

- 식별자 검색 순서
  1. 지역 스코프
  2. 최대 함수 바디
  3. 최대 로컬 파일
  4. 외부 파일까지 확장



### 섹션 16. 메모리와 포인터


96. 컴퓨터 메모리 종류

https://www.inflearn.com/courses/lecture?courseId=331984&unitId=183165


---

97. 포인터 변수 기본 문법


---

98. 포인터와 1차원 배열


---

99. 메모리 동적 할당 및 해제


---

100. 메모리 초기화, 복사, 비교


---

101. [필수 실습 문제] 잘못된 메모리 복사


---

102. 배열 연산자 풀어 쓰기


---

103. 문자열 복사, 비교, 검색


---

104. 동적 할당된 메모리 구조와 realloc()


---

105. 대충 살피는 다중 포인터


---

106. 다차원 배열에 대한 포인터


---

107. 정적 메모리와 기억부류 지정자




## 자료형

- C언어에서 자료형은 **일정 길이의 메모리에 저장된 정보를 해석하는 방법**
- 정보(자료)는 결국 숫자
- 정보(자료)는 변수와 상수 두 종료가 있음
- C언어의 **변수는 메모리를 사용하기 위한 문법**으로 이해할 수 있음

  - 정수형(부호유무, 크기)
    char 데이터타입이 포함되어있는데, 컴퓨터에 저장되는 데이터로는 정수이기 때문에 정수형이라고
    한다. 물론 그걸 ascii문자로 해석해서 화면에 보여주긴 하겠지만.
  - 실수형(크기)
  - 유도형(*, [], 구조체, 공용체)
  - 함수형
  - 무치형(void)

### 정수형

- 컴퓨터의 연산(2진수 연산)

  - 곱셈
    1. 방법 1: 여러번 더하기
    2. 방법 2: `(*2 ==)` 왼쪽 shift 연산 + padding(우측)

  - 나눗셈
    1. 방법 1: 여러번 빼기
    2. 방법 2: `(/2 ==)`오른쪽 shift 연산 + padding(좌측) + 오른쪽 절삭

### 실수형

_부동소수점 오차를 유념하고 유효범위를 고려해 프로그램을 작성한다._

- float : 소수점 이하  6자리 유효 (해상도가 낮아서 잘 안쓴다.)
- double: 소수점 이하 15자리 유효
  - long double은 지원하지 않는 시스템 또는 컴파일러도 있다.





## QnA


> [!qt] 어떤 데이터는 1B로 저장된다. 근데 그 값이 저장된 메모리에 주소값도 있어야해서 어딘가 32b 혹은 64b가 주소값을 위해 저장되어야 한다. 이게 앞뒤가 안맞지 않나?
>   󱞪 원래 그렇다. 모든 메모리를 1B짜리 데이터로 사용하진 않는다.


`인코딩(encoding)`이란, 데이터를 특정한 규칙에 따라 다른 형식(특히, 0과 1의 비트열)으로 변환하는
과정을 의미합니다.


> [!qt] 컴파일링 과정 -> 의역의 가능성이 있다.
>   󱞪 



