# 󰏢 AWS


> [!rf]
>
> [AWS 강의실](https://www.youtube.com/@AWSClassroom)


## 비용 개선

> [!rf]
> [코딩애플 - aws 쓰지 마세요](https://www.youtube.com/watch?v=xUKudCftBCw)



## 기능

### AWS-SDK

_AWS의 다양한 서비스에 접근할 수 있는 API를 제공한다._

- Javascript/Typescript: Node.js 및 브라우저에서 사용 가능



### Cognito

_- 회원가입, 로그인, 사용자 인증, 권한 관리_
_- 로그인에 성공하면 내 App의 url로 리다이렉트 되는 방식_


#### Entiies

- User Pool:
  사용자를 관리하고 인증하는 데 사용하는 저장소. 회원가입, 로그인, 비밀번호 복구 등
  Group 기능을 이용하여 사용자를 나눠서 관리(권한 부여). 이른바 Roll-BAsed Access Control(RBAC)을 구현할 수 있음

- Identity Pool:
  인증된 사용자가 AWS 리소스에 접근할 수 있도록 임시 AWS 자격 증명을 제공. 예를 들어, S3에 파일을 업로드할 수 있는 권한 등

#### Verification Code

확실한 연락 수단을 확보하기 위해 email, phone number를 통한 인증을 요구한다.

이때 인증 코드는 24시간동안 유효하며, 필요시 [ResendConfirmationCode API](https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_ResendConfirmationCode.html)를 호출하여 새로운 코드를 발급할 수 있다.

#### App Client Settings


- Authentication flow session duration
  : 이메일, 전화 등으로 전달받은 인증 코드의 유효 시간

- ID token
  : 사용자 정보 및 인증 상태(유효시간이 만료되면 다시 로그인 하거나 그 전에 세션을 갱신해야한다. 즉, 다시 인증 받아야한다.)
  : JWT 형태이며, OIDC(OpenID Connect) 프로토콜에서 사용

- Access token
  : 사용자가 타겟 리소스를 요청할 수 있는 권한
  : 보통 OAuth 2.0에서 사용(사실상 표준)

- Refresh token expiration
  : ID token과 Access token을 갱신 사용. 반드시 위 2가지보다 더 길어야한다.(아니면 갱신 되기 전에 폐기되니 의미가 없지..)
  : 만료 시간과 별개로 갱신 횟수 등으로 추가 정책이 적용될 수 있다.


> [!qt] Access token과 ID token이 구분되어야 하는 이유는?
>   󱞪 이 질문은 아래 2가지로 나눌 수 있다.
>
>
>  > [!qt] 왜 Acesss 토큰이 더 길어야 하는걸까?
>  >   󱞪 특정한 경우에 사용자 경험을 개선할 수 있기 때문이다. 사례로 설명하면 쉬운데 동영상 스트리밍, 은행 송금 등을 떠올려 볼 수 있다.
>  >
>  >   넷플릭스에서 공유컴퓨터 사용시 보안 등을 위해 ID토큰을 10분정도로 짧게 설정했다고 쳐보자. ID 토큰이 종료되면 다시 로그인해야한다. 이때 Access 토큰이 같은 길이로 설정되어있다면 영화보다가 10분마다 자꾸 로그인하라고 모달창이 뜰 것이다. 이러면 서비스를 제대로 즐길 수 없다.
>  >
>  >   은행 송금을 생각해봐도, 실제 돈을 다루다보니 5분만 자리를 비워도 위험할 수 있다. 그래서 ID 토큰이 짧은데, 이때 Access토큰이 똑같이 5분가량이라면, 잠깐 전화가 온다거나 화장실 다녀왔더니 지금까지 진행한 맥락이 모두 날아가버리는 상황이 발생할 수 있다. 그럼 짜증나겠지.
>
>
>  > [!qt] 왜 ID 토큰이 더 짧아야 하는걸까?
>  >   󱞪 위에서 말한것처럼 PC방 등 공유기기에서의 문제 따위다. 깜빢하고 로그아웃을 안했을 뿐인데 유구한 세월 인증이 살아있고, 민감한 정보가 누출되면 곤란할 수 있다.
>
>
>  > [!qt] 어차피 갱신 되니까 상관없는거 아닌가?
>  >   󱞪 사용자 입장에선 맞다. 어떤 조건에서 토큰이 갱신될지 잘 설계 해두면 사용자 입장에선 보안상 안전하면서도 편의성을 해치지 않게 된다.
>
>
> [!ye] 단, 비교적 단순한 서비스의 겨우라면 외부 의존성에 ID토큰이 반드시 필요하지 않은 이상 Access토큰만 사용해도 무방하다.
> [비슷한 고민을 했던 글](https://www.reddit.com/r/aws/comments/13pod67/api_gateway_and_cognito_using_the_id_token_for/)



### RDS


#### 스토리지 유형

| 스토리지 유형 | IOPS         | 특징                      | 가격      | 사용 사례                |
|---------------|--------------|---------------------------|-----------|--------------------------|
| gp2           | 100–16,000   | 스토리지 크기와 IOPS 연동 | 저렴      | 테스트/소규모 프로덕션   |
| gp3           | 3,000–16,000 | 성능 조정 가능            | 적당      | 고성능 요구 환경         |
| io1           | 최대 64,000  | 안정적인 고성능           | 높음      | 고성능 데이터베이스      |
| io2           | 최대 256,000 | 최고 내구성 및 성능       | 매우 높음 | 미션 크리티컬 시스템     |
| Magnetic      | 최대 1,000   | 저성능                    | 매우 저렴 | 비추천, 단순 테스트 용도 |
  - IOPS: Input/Output Operations Per Second


#### Multi-AZ Deployment in AWS RDS

_- 데이터베이스를 여러 가용 영역에 복제하여 고가용성과 장애 복구를 보장하는 기능_
_- 기본 인스턴스와 스탠바이 인스턴스로 구성_
_- 장애 발생 시 자동으로 스탠바이 인스턴스로 전환_

- 주요 특징
  - 자동 장애 조치: 장애 시 스탠바이 인스턴스로 자동 전환
  - 동기적 복제: 데이터를 실시간으로 복제
  - 데이터 무결성 보장: 데이터 손실 방지
  - 백업 작업 최적화: 백업 작업이 기본 인스턴스 성능에 영향을 주지 않음

- 장점
  - 고가용성: 장애 시에도 서비스 지속 가능
  - 데이터 안정성: 실시간 복제를 통해 데이터 손실 방지
  - 운영 편의성: 장애 조치와 복구가 자동화
  - 백업 효율성: 스탠바이 인스턴스를 활용한 백업으로 성능 저하 방지

- 단점
  - 비용 증가: 스탠바이 인스턴스도 비용이 발생
  - 쓰기 성능 저하: 동기적 복제로 인해 쓰기 레이턴시 증가 가능

- 스탠바이 인스턴스를 설정해야 하는 경우
  - 프로덕션 환경
  - 고가용성과 데이터 무결성이 중요한 경우
  - 서비스 가동 시간이 중요하거나 장애 복구 목표가 엄격한 경우

- 스탠바이 인스턴스를 설정하지 않아도 되는 경우
  - 개발 및 테스트 환경
  - 비용 절감이 중요한 경우
  - 멀티 리전을 활용한 재해 복구를 고려하는 경우


#### VPC

_- AWS에서 제공하는 가상 네트워크 환경_
_- 논리적으로 격리된 네트워크를 제공_
_- AWS 안의 개인 데이터센터와 같은 역할_

- 구성 요소 요약
  | 구성 요소          | 역할                                        |
  |-------------------|-------------------------------------------|
  | CIDR 블록         | VPC의 IP 주소 범위를 정의                   |
  | 서브넷            | 퍼블릭 또는 프라이빗 네트워크 세그먼트        |
  | 인터넷 게이트웨이   | VPC를 인터넷에 연결                        |
  | 라우팅 테이블      | 트래픽 경로를 정의                         |
  | 보안 그룹          | 리소스 단위로 인바운드/아웃바운드 트래픽 제어 |
  | 네트워크 ACL       | 서브넷 단위로 트래픽 제어                   |

- 사용 이유
  - 보안 강화: 네트워크 격리를 통해 외부 접근 차단
  - 네트워크 제어: IP 주소와 트래픽 경로를 직접 정의
  - 리소스 배포 최적화: 퍼블릭/프라이빗 서브넷으로 분리된 리소스 배치
  - 하이브리드 클라우드 지원: 온프레미스와 AWS 간 연결 가능

- 예시
  1. VPC 생성 후 CIDR 블록 지정 (예: 192.168.0.0/16)
  2. 퍼블릭 서브넷과 프라이빗 서브넷 생성
  3. EC2 인스턴스를 퍼블릭 서브넷에 배치
  4. 민감한 데이터는 프라이빗 서브넷의 데이터베이스에 저장
  5. 보안 그룹으로 EC2와 데이터베이스 간 트래픽만 허용


#### RDS와 Cognito의 통합

> [!qt] Cognito를 사용한다면 user테이블 역할을 userPool이 대체한다. 그렇다면 이 두가지를 어덯게 연동해서 써야할까?
>
>
> 1. Cognito UserPool 변경 시점:
>
>   - 회원가입 완료 → user_mapping_table에 새 레코드 생성
>   - 회원 정보 수정 (이메일, 전화번호 등) → user_mapping_table 업데이트
>   - 회원 탈퇴 → user_mapping_table의 status를 '탈퇴'로 변경
>
> 2. 일반 서비스 운영 시:
>
>   - 게시글 작성, 댓글 등록 등의 작업에서는 user_mapping_table의 user_id를 외래키로 사용
>   - 사용자 정보 표시가 필요할 때는 user_mapping_table에서 조회
>   - Cognito에 추가 인증/인가가 필요한 경우가 아니라면 user_mapping_table만 참조
>
> _이렇게 하면:_
>
>   - Cognito는 순수하게 인증/인가 용도로만 사용
>   - 서비스 내부 로직은 RDS의 user_mapping_table을 통해 처리
>   - Cognito와 RDS 간의 데이터 정합성은 중요 이벤트(가입,수정,탈퇴) 시점에만 관리하면 됨


### S3


#### Keyword

- 버킷
  - 객체를 담는 그릇(데이터의 저장공간을 구분하는 단위)
  - 버킷 이름은 고유하다.(region과 관계 없이 고유함)


- S3 객체(파일)의 구성
  | 이름       | 설명                                       |
  |------------|--------------------------------------------|
  | Owner      | 소유자                                     |
  | Key        | 파일의 이름                                |
  | Value      | 파일의 데이터                              |
  | Metadata   | 파일의 메타데이터(입맛대로)                |
  | Version Id | 파일의 version Id (versioning이 가능하다.) |
  | ACL        | 파일 접근 권한                             |
  | Torrents   | 토렌트 공유를 위한 데이터                  |


#### 보안 설정

- 파일은 암호화되어 제공된다.
- 객체 단위와 버킷 단위로 구성
  - Bucket Policy: 버킷 단위, **주로 이용**
  - ACL(Access Control List): 객체 단위, 잘 안쓴다.

- MFA를 활용해 삭제 방지 기능 제공
- Versioning 가능
- Access Log 기록 및 전송 가능

- 버킷 내에 디렉토리 구조가 실제로 존재하는건 아니다. 단지 Key값에 '/'를 넣어서 가독성을 높이는 것 뿐이다.
  예시)
  - 버킷명: `mybucket`
  - key: `my-root/my-dir/file.txt`

- cors 설정 예시

  ```json
  [
    {
      "AllowedHeaders": [ "*" ],
      "AllowedMethods": [ "GET", "POST", "PUT", "DELETE", "HEAD" ],
      "AllowedOrigins": [ "http://localhost:5173", "http://127.0.0.1:5173" ], // 개발 서버
      "ExposeHeaders": [ "ETag" ],
      "MaxAgeSeconds": 0 // preflight 요청을 캐싱할 시간, 너무 짧으면 성능 이슈가 있다.
    }
  ]
  ```

#### 비용 최적화(Storage Class)


[!ye] 저장 용량에 따른 비용이 기본이며, 경우에 따라 데이터 접근 빈도에도 비용이 붙는다.

[!ye] 네트워킹(전송) 비용은 당연히 별도로 발생한다.


- S3 Standard
  - 가장 일반적인 스토리지 클래스
  - 높은 내구성과 가용성 제공
  - 빠른 데이터 접근 속도

- S3 Intelligent-Tiering
  - 자동으로 데이터 액세스 패턴을 분석하여 최적의 스토리지 클래스로 이동
  - 자주 액세스하는 데이터에 대해 S3 Standard, 드물게 액세스하는 데이터에 대해 S3 Standard-IA로 이동

- S3 Standard-IA(Infrequent Access)
  - 자주 액세스하지 않는 데이터에 대한 비용 절감
  - 데이터를 저장할 때는 S3 Standard와 동일한 비용
  - 데이터를 검색할 때만 추가 비용


이 밖에도 접근 빈도에 따라 요금이 달라지는 여러 클래스가 있다. 아카이빙 단계까지도 있는데, 파일에 엑세스 하기까지 12~48시간 정도 소요되는 것 까지 있다.


#### 접근 권한 관리

> [!ye] 토막상식
>
> - AWS의 리소스 접근 권한 관리는 여러 계층에 걸쳐 이루어진다.
> - 이 계층들은 두가지 정책으로 구분할 수  있는데,
>   - IAM 기반 정책: 사용자, 그룹, 역할에 대한 권한 관리. 즉, 자격 부여받은 사용자이거나 또는 그룹에 속하는 손님(요청자)인지 따진다.
>   - 리소스 기반 정책: 방문 목적이 되는 리소스 입장에서 접근 허용 여부를 결정. 즉, 손님이 방문했을 때 집주인이 허락 할지말지 결정한다.
> - 우선적으로 평가되는 순위부터 모두 통과해야 최종적으로 리소스에 접근이 허용된다.
> - 단, 3번째 단계에 해당하는 **리소스 기반 정책**만큼은 예외인데, 여기서 허용되면 나머지는 상관없이 접근이 허용된다.


- 버킷 정책:
  - 버킷 단위로 부여되는 **리소스 기반 정책**
  - 리소스의 계층 구조에 따라 권한 조절 가능
  예시)
  ```json
  {
    "Version": "2012-10-17",
    "Statement": [
      {
        "Effect": "Allow", // 허용 여부? 응, 허용
        "Principal": "*", // 누구에게 허용? 모든 사용자
        "Action": "s3:GetObject", // 어떤 행동을 허용? 객체 읽기
        "Resource": "arn:aws:s3:::my-bucket/*" // 어떤 리소스에 대해 허용? my-bucket의 모든 객체
      }
    ]
  }
  ```


#### 버전 관리

- 객체의 생성, 업데이트, 삭제의 모든 이력을 저장
- Soft Delete(삭제된 객체를 복구 가능)
- 버킷 단위로 활성화. 중지는 가능하다 비활성화는 불가능

- 리소스 요청자가 Key로 접근 시 항상 최신 버전을 반환(Key는 모두 같다.)
- 삭제 시에는 해당 버전만 삭제 되고, 이전 버전들은 그대로 남음
  - 소프트 삭제라서 '삭제 마커'만 되돌리면 간단히 복구된다.
  - 버전 삭제를 할 수도 있다. 그럼 이전 버전이 반환 된다.
- 각 버전들은 별도의 비용이 발생. (버전이 많아지면 비용이 늘어난다.) 그래서 기본적으로 비활성화


#### 객체 잠금

- 필요에 따라 객체를 잠금하여 변경을 방지
- 잠금을 해제하는 방법에 따라 나뉨
  - 절대 불가
  - 기간동안 불가
  - 권한 없으면 불가

#### Static Web Hosting

- 아키텍쳐는 Client - CloudFront - S3로 구성된다.

- 버킷명과 도메인이 일치해야 함
  - 내 도메인도 빼앗길 수 있으니 중요한 주소라면 미리 선점할 필요가 있다.

- HTTPS 지원을 위해 반드시 CloudFront 연동
- 보통은 Public Hosting 활성화 대신 그대로 Private으로 두고 OAI/OAC 등을 활용해서 보안을 강화

[따라하기](https://www.youtube.com/watch?v=RyfowGtwekg)

#### 접근 방법 Up/Down




