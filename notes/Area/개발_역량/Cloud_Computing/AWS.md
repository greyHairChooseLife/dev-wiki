# 󰏢 AWS


### AWS-SDK

_AWS의 다양한 서비스에 접근할 수 있는 API를 제공한다._

- Javascript/Typescript: Node.js 및 브라우저에서 사용 가능



### Cognito

_- 회원가입, 로그인, 사용자 인증, 권한 관리_
_- 로그인에 성공하면 내 App의 url로 리다이렉트 되는 방식_


#### Entiies

- User Pool:
  사용자를 관리하고 인증하는 데 사용하는 저장소. 회원가입, 로그인, 비밀번호 복구 등
  Group 기능을 이용하여 사용자를 나눠서 관리(권한 부여). 이른바 Roll-BAsed Access Control(RBAC)을 구현할 수 있음

- Identity Pool:
  인증된 사용자가 AWS 리소스에 접근할 수 있도록 임시 AWS 자격 증명을 제공. 예를 들어, S3에 파일을 업로드할 수 있는 권한 등

#### Verification Code

확실한 연락 수단을 확보하기 위해 email, phone number를 통한 인증을 요구한다.

이때 인증 코드는 24시간동안 유효하며, 필요시 [ResendConfirmationCode API](https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_ResendConfirmationCode.html)를 호출하여 새로운 코드를 발급할 수 있다.

#### App Client Settings


- Authentication flow session duration
  : 이메일, 전화 등으로 전달받은 인증 코드의 유효 시간

- ID token
  : 사용자 정보 및 인증 상태(유효시간이 만료되면 다시 로그인 하거나 그 전에 세션을 갱신해야한다. 즉, 다시 인증 받아야한다.)
  : JWT 형태이며, OIDC(OpenID Connect) 프로토콜에서 사용

- Access token
  : 사용자가 타겟 리소스를 요청할 수 있는 권한
  : 보통 OAuth 2.0에서 사용(사실상 표준)

- Refresh token expiration
  : ID token과 Access token을 갱신 사용. 반드시 위 2가지보다 더 길어야한다.(아니면 갱신 되기 전에 폐기되니 의미가 없지..)
  : 만료 시간과 별개로 갱신 횟수 등으로 추가 정책이 적용될 수 있다.


> [!qt] Access token과 ID token이 구분되어야 하는 이유는?
>   󱞪 이 질문은 아래 2가지로 나눌 수 있다.
>
>
>  > [!qt] 왜 Acesss 토큰이 더 길어야 하는걸까?
>  >   󱞪 특정한 경우에 사용자 경험을 개선할 수 있기 때문이다. 사례로 설명하면 쉬운데 동영상 스트리밍, 은행 송금 등을 떠올려 볼 수 있다.
>  >
>  >   넷플릭스에서 공유컴퓨터 사용시 보안 등을 위해 ID토큰을 10분정도로 짧게 설정했다고 쳐보자. ID 토큰이 종료되면 다시 로그인해야한다. 이때 Access 토큰이 같은 길이로 설정되어있다면 영화보다가 10분마다 자꾸 로그인하라고 모달창이 뜰 것이다. 이러면 서비스를 제대로 즐길 수 없다.
>  >
>  >   은행 송금을 생각해봐도, 실제 돈을 다루다보니 5분만 자리를 비워도 위험할 수 있다. 그래서 ID 토큰이 짧은데, 이때 Access토큰이 똑같이 5분가량이라면, 잠깐 전화가 온다거나 화장실 다녀왔더니 지금까지 진행한 맥락이 모두 날아가버리는 상황이 발생할 수 있다. 그럼 짜증나겠지.
>
>
>  > [!qt] 왜 ID 토큰이 더 짧아야 하는걸까?
>  >   󱞪 위에서 말한것처럼 PC방 등 공유기기에서의 문제 따위다. 깜빢하고 로그아웃을 안했을 뿐인데 유구한 세월 인증이 살아있고, 민감한 정보가 누출되면 곤란할 수 있다.
>
>
>  > [!qt] 어차피 갱신 되니까 상관없는거 아닌가?
>  >   󱞪 사용자 입장에선 맞다. 어떤 조건에서 토큰이 갱신될지 잘 설계 해두면 사용자 입장에선 보안상 안전하면서도 편의성을 해치지 않게 된다.
>
>
> [!ye] 단, 비교적 단순한 서비스의 겨우라면 외부 의존성에 ID토큰이 반드시 필요하지 않은 이상 Access토큰만 사용해도 무방하다.
> [비슷한 고민을 했던 글](https://www.reddit.com/r/aws/comments/13pod67/api_gateway_and_cognito_using_the_id_token_for/)



### RDS


#### 스토리지 유형

| 스토리지 유형 | IOPS         | 특징                      | 가격      | 사용 사례                |
|---------------|--------------|---------------------------|-----------|--------------------------|
| gp2           | 100–16,000   | 스토리지 크기와 IOPS 연동 | 저렴      | 테스트/소규모 프로덕션   |
| gp3           | 3,000–16,000 | 성능 조정 가능            | 적당      | 고성능 요구 환경         |
| io1           | 최대 64,000  | 안정적인 고성능           | 높음      | 고성능 데이터베이스      |
| io2           | 최대 256,000 | 최고 내구성 및 성능       | 매우 높음 | 미션 크리티컬 시스템     |
| Magnetic      | 최대 1,000   | 저성능                    | 매우 저렴 | 비추천, 단순 테스트 용도 |
  - IOPS: Input/Output Operations Per Second


#### Multi-AZ Deployment in AWS RDS

_- 데이터베이스를 여러 가용 영역에 복제하여 고가용성과 장애 복구를 보장하는 기능_
_- 기본 인스턴스와 스탠바이 인스턴스로 구성_
_- 장애 발생 시 자동으로 스탠바이 인스턴스로 전환_

- 주요 특징
  - 자동 장애 조치: 장애 시 스탠바이 인스턴스로 자동 전환
  - 동기적 복제: 데이터를 실시간으로 복제
  - 데이터 무결성 보장: 데이터 손실 방지
  - 백업 작업 최적화: 백업 작업이 기본 인스턴스 성능에 영향을 주지 않음

- 장점
  - 고가용성: 장애 시에도 서비스 지속 가능
  - 데이터 안정성: 실시간 복제를 통해 데이터 손실 방지
  - 운영 편의성: 장애 조치와 복구가 자동화
  - 백업 효율성: 스탠바이 인스턴스를 활용한 백업으로 성능 저하 방지

- 단점
  - 비용 증가: 스탠바이 인스턴스도 비용이 발생
  - 쓰기 성능 저하: 동기적 복제로 인해 쓰기 레이턴시 증가 가능

- 스탠바이 인스턴스를 설정해야 하는 경우
  - 프로덕션 환경
  - 고가용성과 데이터 무결성이 중요한 경우
  - 서비스 가동 시간이 중요하거나 장애 복구 목표가 엄격한 경우

- 스탠바이 인스턴스를 설정하지 않아도 되는 경우
  - 개발 및 테스트 환경
  - 비용 절감이 중요한 경우
  - 멀티 리전을 활용한 재해 복구를 고려하는 경우


#### VPC

_- AWS에서 제공하는 가상 네트워크 환경_
_- 논리적으로 격리된 네트워크를 제공_
_- AWS 안의 개인 데이터센터와 같은 역할_

- 구성 요소 요약
  | 구성 요소          | 역할                                        |
  |-------------------|-------------------------------------------|
  | CIDR 블록         | VPC의 IP 주소 범위를 정의                   |
  | 서브넷            | 퍼블릭 또는 프라이빗 네트워크 세그먼트        |
  | 인터넷 게이트웨이   | VPC를 인터넷에 연결                        |
  | 라우팅 테이블      | 트래픽 경로를 정의                         |
  | 보안 그룹          | 리소스 단위로 인바운드/아웃바운드 트래픽 제어 |
  | 네트워크 ACL       | 서브넷 단위로 트래픽 제어                   |

- 사용 이유
  - 보안 강화: 네트워크 격리를 통해 외부 접근 차단
  - 네트워크 제어: IP 주소와 트래픽 경로를 직접 정의
  - 리소스 배포 최적화: 퍼블릭/프라이빗 서브넷으로 분리된 리소스 배치
  - 하이브리드 클라우드 지원: 온프레미스와 AWS 간 연결 가능

- 예시
  1. VPC 생성 후 CIDR 블록 지정 (예: 192.168.0.0/16)
  2. 퍼블릭 서브넷과 프라이빗 서브넷 생성
  3. EC2 인스턴스를 퍼블릭 서브넷에 배치
  4. 민감한 데이터는 프라이빗 서브넷의 데이터베이스에 저장
  5. 보안 그룹으로 EC2와 데이터베이스 간 트래픽만 허용


#### RDS와 Cognito의 통합

> [!qt] Cognito를 사용한다면 user테이블 역할을 userPool이 대체한다. 그렇다면 이 두가지를 어덯게 연동해서 써야할까?
>
>
> 1. Cognito UserPool 변경 시점:
>
>   - 회원가입 완료 → user_mapping_table에 새 레코드 생성
>   - 회원 정보 수정 (이메일, 전화번호 등) → user_mapping_table 업데이트
>   - 회원 탈퇴 → user_mapping_table의 status를 '탈퇴'로 변경
>
> 2. 일반 서비스 운영 시:
>
>   - 게시글 작성, 댓글 등록 등의 작업에서는 user_mapping_table의 user_id를 외래키로 사용
>   - 사용자 정보 표시가 필요할 때는 user_mapping_table에서 조회
>   - Cognito에 추가 인증/인가가 필요한 경우가 아니라면 user_mapping_table만 참조
>
> _이렇게 하면:_
>
>   - Cognito는 순수하게 인증/인가 용도로만 사용
>   - 서비스 내부 로직은 RDS의 user_mapping_table을 통해 처리
>   - Cognito와 RDS 간의 데이터 정합성은 중요 이벤트(가입,수정,탈퇴) 시점에만 관리하면 됨
