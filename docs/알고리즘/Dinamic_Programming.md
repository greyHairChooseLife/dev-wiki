# Dinamic Programming



- **하향식(Top-Down, 메모이제이션)**

  - 큰 문제를 작은 하위 문제로 쪼개면서 재귀적으로 해결
  - 이미 계산한 하위 문제의 결과는 저장(메모이제이션)해서 중복 계산 방지
  - 주로 재귀 함수 + 캐시(배열, 딕셔너리) 사용

  - 예시 (피보나치 수열)
    ```python
    def fib(n, memo={}):
        if n <= 1:
            return n
        if n not in memo:
            memo[n] = fib(n-1, memo) + fib(n-2, memo)
        return memo[n]
    ```


**상향식(Bottom-Up, 타뷸레이션)**

  - 가장 작은 하위 문제부터 차례대로 해결해서, 점점 큰 문제로 확장
  - 반복문을 사용해서 DP테이블을 채움
  - 재귀 없이 순차적으로 계산

  - 예시 (피보나치 수열)
    ```python
    dp = [0, 1] + [0] * (n-1)
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
     ```


- **차이점 요약**

  - 하향식: 재귀 + 메모이제이션, 코드가 간결, 호출 스택 사용
  - 상향식: 반복문 + DP테이블, 메모리/속도 효율적, 스택 오버플로우 없음



- **문제 풀이에 적용하는 사고방식**

  ```
  1. DP로 풀 수 있는 문제인지 판단하기
     - 중복되는 하위 문제가 있는지, 최적 부분 구조가 성립하는지 확인
     ex)
       - 피보나치 수열은 n번째 항을 구할 때 n-1, n-2번째 항을 이용한다.
       - 같은 하위 문제가 여러 번 등장하므로 DP로 풀 수 있다.

  2. 상태(state) 정의하기
     - DP 테이블에 담긴 값이 무엇인지 명확히 설정
     - DP 테이블의 인덱스가 무엇을 의미하는지 명확히 설정
     ex)
       - dp[i]를 i번째 피보나치 수라고 정의한다.

  3. 점화식(transition) 세우기
     - 현재 상태를 이전 상태(또는 여러 상태)로부터 어떻게 계산할지 식을 세움
     ex)
       - dp[i] = dp[i-1] + dp[i-2]로 나타낼 수 있다.

  4. 메모이제이션 구조 설계하기
     - 1차원, 2차원, 혹은 더 복잡한 구조가 필요한지 결정
     ex)
       - n이 크지 않으므로 1차원 배열 dp를 사용한다.

  5. 초기값(base case) 설정하기
     - DP 테이블의 시작값을 올바르게 지정
     ex)
       - dp[0] = 0, dp[1] = 1로 시작한다.

  6. 최종 해답 위치 확인하기
     - DP 테이블의 어떤 값이 문제의 정답인지 파악
     ex)
       - dp[n]이 원하는 답이 된다.
  ```


- 선목님의 사고방식
  
  1. 일단 재귀든 뭐든 완전 탐색으로 풀어본다.
     - 안풀리면 패턴을 찾는다.
     - 풀리면 최적화한다.(DP)
