
**정렬의 분류**

  - 안정 vs 불안정

    값이 정렬된 후에도 가능한 정렬 이전의 index를 유지(크기가 동일한 것 사이에)


  - 내부 vs 외부정렬
    
    정렬 하려는 배열만 가지고도 정렬할 수 있는 경우
    (어떤 정렬은 임시로 어디에 넣어둬야한다.)


---

**단순정렬 `O(N^2)`**
  
  - 버블 정렬: 바로 옆에랑 비교해서 자리바꾸기를 연속적으로
    - 개선 1: 마지막 pass 지점 기록해서 안해도 될 일은 안하기
    - 개선 2: 우>>좌, 좌<<우 반복하는 shaker 정렬

    - 두개 동시에 쓰면 될듯?


  - 선택 정렬: 아직 정렬 안된 애들중에 젤 작은거 찾아서 쌓아가기
    - 이런식이면 이제 순서가 바뀌는 불안정 정렬
   

  - 삽입 정렬:

    이미 정렬 된 애들중에서 비교해가며 자리를 찾는다. 한번 자리 찾으면 이후로는 비교 안해도
    되니까 어느정도 정렬이 되어있을수록 빠를 가능성이 높음

    이론상 시간복잡도 `O(N^2)`이지만 보통 효율 좋음



  - > [!nt] 선택정렬 vs 삽입정렬
    >
    > 이놈들은 언뜻 보기에는 똑같아 보인다. 다른 점은 '이번에 정렬할 원소'의 위치를 얻기 위해
    > 비교가 어디에서 이루어지는가이다.
    > 
    > 두 정렬 방법 모두 좌측(또는 한 쪽)에 정렬된 애들을 쌓아가는 방식인데,
    > 
    >   **선택정렬은 나머지를 비교**하여 가장 작은 애를 찾아야한다. 즉, 아직 정렬되지 않은 우측
    >   애들을 전부다 비교해 봐야한다.
    > 
    >   반면, **삽입정렬은 이미 정렬 된 애들 사이에서 비교**한다.
    > 
    > 이렇게 되면 '선택정렬'은 아직 정렬되지 않은애들의 개수만큼 반드시 비교해야하고,
    > '삽입정렬'은 가장 크거나 작은 쪽부터 비교해 들어가다가 자리를 찾으면 그 이상은 비교하지
    > 않아도 된다.
    > 
    > 그래서 이미 어느정도 정렬이 되어있는 상태라면 매우 좋은 효율을 보이고, 최악의 경우라도
    > 선택정렬보다 뒤떨어지진 않는다.
