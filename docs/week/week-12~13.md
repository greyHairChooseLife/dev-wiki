# week-12: Pintos - Virtual Memory



> [!nt]
>
> 팀원: 김창민 + 김민재




> [!nt] PR 단위는 아래처럼
>
> - 
> - 
> - 



> [!rf]
> 
> [team 레포](https://github.com/jungle-cs-lab/pintos_ubuntu_22.04)
> [나](https://github.com/greyHairChooseLife/pintos_ubuntu_22.04_11W_team)



## 코치님 발제 (윤선코치님)

> [!lg] Log 2025-11-28
>
> 코치님들마다 스타일이 다른게, 윤선 코치님이 오시자 발제시간에 이전보다 많은 힌트를 주셨다. 우리가
> 무엇을 다루게 되는지, 그래서 어떤 키워드나 흐름으로 공부해야하는지 말이다.


- 지금까지는 Page를 user pool, kernel pool에서 당연하게 할당 받았지만, 앞으로는 직접 해야한다.
- 즉, Page Fault에 직접 대응해야한다.
- Page Fault에 대응하는 방법은 여러가지 있을 수 있다.
    - 유휴 공간이 넉넉한 경우
    - 유휴 공간이 부족해 vimtim을 선택해야 하는 경우
- 관려해서 SPT라는게 개념이 등장한다.
    - Page를 관리하는 개념이다.
    - process 단위로 관리된다.



- 커널 모드에서 유저용 virtual address를 사용할 수 없다. 동일한 Page에 KVA를 활용해야한다.




## PR 리뷰 



- PR 메시지를 봤을 때 구현 내용을 "(코드 베이스 내에)foo함수를 구현"처럼 표현하면, 코드베이스에 대한
  기억이나 이해가 없을 때 뭘했다는건지 알 수가 없다.

- 순서가 그냥 github에서 changed files로 한번에 위에서 아래로 보면 상당히 어렵다. 맥락 잡기가.
    - 시간이 좀 지나면 스스로도 보기어 려울듯!?

- 듣는 사람이 이해하고 있는지 확인하면서 리뷰를 가이드해주고 있는가?



## 전체 시스템 이해하기

### mj

- 마운트가 맞냐 로딩이 맞냐?
- 부트로더 vs 바이오스 차이점?
- OS가 어디있는줄 알고 마운트를 하지?
- RAM에 마운트(로딩)되면 고정된 위치에 저장되냐?
- OS랑 커널은 무슨 차이인가?
- 커널도 프로세스가 존재하나? 쓰레드만 있는거냐? 가상주소공간을 가지기는 하냐?
- CPU의 레지스터가 원래는 텅텅 비어있을텐데, bios에 의해 시스템이 시작되면 맨처음 어느 레지스터
  가 어떻게 채워지나?
- OS의 main 함수는 언제 어떻게 실행되나? 누가 호출하나?
- bss_init이 뭐하는애냐?



### cm

- bss_init BSS 영역(물리메모리)을 초기화 한다는데 그건 어디에 있나?
- kernel.lds.S 이거 뭐하는거냐?

- 이건 source로 어떤 문자열을 어떻게 받아서 반환해주나? 전달 해주는 인자가 없다.
    - File Path: threads/init.c, 76:77
      ```c
          argv = read_command_line();
          argv = parse_options(argv);
      ```


- main함수가 실행되는동안 선언된 지역변수들은 어디에 저장 되고있는건가?

- palloc_init을 통해 물리메모리에 꼭데기 세칸을 꽉 채운건가?
    BSS - kerel pool - user pool

- "Booting from hardisk ..." 이라고 문자열이 테스트코드 실행하면 출력되는애는 main함수가 실행되기도
  전인데 그럼 누가 출력하는거지? console init도 하기 전인데



### sy


**부팅 종료**
인터럽트 셋업
타이머 인터럽트
컨텍스트 스위칭
쓰레드 생명주기
**페이징 시스템**
**시스템 콜**
fork & exec
가상주소공간 & 물리주소공간


- 30분 공부
- 30분 내용 합치기

를 반복한다.


## 주요 흐름

### bootup

디스크에서 읽어와서 지정된 메모리 위치에 로드

1sector  

16b 실모드


32비트 보호모드

커널 이미지 메모리로 로 



64bit 롱 모드

PT, paging, syscall 활성화



---

### system call


syscall_init();




## /home/sy/jg/04.pintos/project.3/threads/start.S


네, 정확합니다! **하나의 어셈블리 파일 안에 여러 섹션(.section)이 존재할 수 있으며, 링커(Linker)가 이를 최종 실행 파일의 서로 다른 위치에 배치할 수 있습니다.**

보통 링커 스크립트(`linker.ld`)가 이 배치를 결정하는데, `.entry` 섹션은 물리 메모리의 시작점(여기서는 `0x20000`)에 배치하고, `.text` 섹션은 그 뒤나 커널 영역 등 다른 곳에 배치하도록 설정되어 있을 것입니다.

질문하신 주요 레이블들의 역할은 다음과 같습니다.

### 1. `bootstrap:` (32-bit 모드 진입점)
부트로더가 점프해오는 **실질적인 시작점**입니다. 아직 32비트 모드입니다.
*   **CPU 기능 확인:** 현재 CPU가 64비트(Long Mode)를 지원하는지 검사합니다. (`cpuid` 명령어 사용)
*   **PAE 활성화:** 64비트 페이징을 사용하기 위한 필수 조건인 PAE(Physical Address Extension) 비트를 `cr4` 레지스터에 설정합니다.

### 2. `setup_page_table:` (임시 페이지 테이블 생성)
64비트 모드로 넘어가려면 **반드시 페이징(Paging)이 켜져 있어야 합니다.** 이를 위해 임시 페이지 테이블을 만듭니다.
*   **계층 구조 연결:** PML4 -> PDPT -> PDE 순서로 페이지 테이블 주소를 연결합니다.
*   **메모리 맵핑 준비:** 커널이 로드된 물리 메모리 영역을 가상 주소와 연결할 준비를 합니다.

### 3. `fill_pdes:` (페이지 디렉토리 채우기)
실제로 메모리 주소를 매핑하는 루프입니다.
*   **2MB 단위 매핑:** 4KB가 아닌 2MB 단위(Huge Page)로 메모리를 매핑하여 초기 설정을 단순화합니다.
*   **Identity Mapping:** 물리 주소와 가상 주소를 1:1로 매핑하거나, 커널 베이스 주소에 맞춰 매핑하여 64비트 전환 직후에 CPU가 길을 잃지 않게 합니다.

### 4. `no_long_mode:` (에러 처리)
*   만약 CPU가 64비트를 지원하지 않는 구형이라면 이곳으로 점프합니다.
*   **무한 루프:** 더 이상 진행할 수 없으므로 여기서 멈춥니다.

### 5. `gdt64:` & `gdt_desc64:` (64비트 GDT 정의)
*   **GDT (Global Descriptor Table):** 64비트 모드용 세그먼트 정보를 정의한 데이터입니다.
*   **코드/데이터 세그먼트:** 64비트 코드 세그먼트와 데이터 세그먼트를 정의합니다. `lgdt` 명령어로 로드되어 CPU에게 "이제부터 64비트 세그먼트를 쓴다"고 알려줍니다.

### 6. `boot_pml4e` ~ `boot_pde2` (페이지 테이블 메모리 공간)
*   **공간 예약:** 코드가 아니라 **데이터 공간**입니다.
*   `.space 0x1000`: 각 테이블마다 4KB(4096바이트)씩 0으로 채워진 공간을 확보해 둡니다. 위에서 본 `setup_page_table` 코드가 이 공간에 값을 씁니다.
