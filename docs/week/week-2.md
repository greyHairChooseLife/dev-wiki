# 󰏢 week-2


> [!nt]
>
> 팀원: 임익화님 +김현서님
>


> [!tdd]
>
> - [x] 코어시간 정하기
>   - 20:00~21:00


> [!td]
>
> - [ ] 스택, 큐, 우선순위큐 하/중 모두 풀어보기, ~ 2025-09-13 (토)
> - CSAPP 4꼭지를 하루/하루/이틀/이틀로 읽고 공유하기
>   - [x] 1/4 정보의 저장
>   - [ ] 2/4 정수의 표시
>   - [ ] 3/4 정수의 산술연산
>   - [ ] 4/4 부동소수점



## 정보의 표현과 처리(Chapter 2)


_* 복잡한 수식이나 계산은 제외_

### 정보의 저장

비트에는 단순히 0과 1 단 두가지만 기록할 수 있지만, 다발로 묶어서 표현할 수 있는 패턴에 의미를
부여하도록 약속된 해석방법(인코딩)을 적용한다면, 말그대로 약속된 의미를 나눌 수 있게 된다. 아무
의미 없는 비트들도 우리가 약속된 방식으로 통제한다면 그안에 소통가능한 의미를 담을 수 있다.

중요한 것은 약속된 방식을 이해하는 것이다. 컴퓨터로 `0.1 * 0.1`을 수십번 반복해보면 인간의
관점으로는 이해할 수 없는 결과가 나온다.

이처럼 컴퓨터의 관점에서 정보를 어떻게 저장하고 해석하는지를 제대로 알지 못하면 예상밖의 크고 작은
문제가 생길 수 있다.


#### 16진수 표시

- 16진수로 값을 표현하는 것은 인간을 위한 것이다. 사람이 컴퓨터의 출력을 보고 의미를 이해할 수
  있어야한다.

  근데 그게 기본 상태인 2진수로 표현되면, 할 수 있겠지만 보기가 어렵다. 효율적으로 2진수와
  매핑되면서 사람이 읽기 쉬운 진법이 16진수이기 때문에 널리 사용된다.

#### 데이터의 크기

- 모든 컴퓨터는 word size를 규격으로 가지는데, 이것은 **포인터의 정규 크기**에 해당한다.
- 하나의 가상주소가 하나의 word로 인코딩되기 때문에, 이것에 영향받는 가장 중요한 시스템 변수에
  가상주소공간의 크기가 있다.
  - 메모리 (참조)주소는 1byte당 하나씩 할당된다.
  - 32bit (word) architecture ==> 64bit (word) architecture가 보편화 되었다. 
    - 이것은 가상메모리 공간을 최대 4GB까지 활용할 수 있던것이 17,179,869,184GB까지 활용할 수 있는
      변화를 가져왔다.
    - 1byte당 주소값 1개가 할당되는데, 32비트에 담을 수 있는 주소값의 종류(경우의 수)는 2^32이기
      때문에 이런 계산이 나온다. 주소값을 구분할 수 있어야 메모리를 쓸 수 있으니까.

- 대부분의 64bit 컴퓨터는 32bit 시스템을 목표로 컴파일된 실행파일도 실행할 수 있다. 그러니까
  어떤 프로그램이 실행되는 조건은 실행되는 머신의 종류가 아니라 '어떻게 컴파일 되었는가'이다.

- C언어를 기준으로, 데이터 타입에 따라 크기가 다양하다.

#### 주소 지정과 바이트 순서

- 주소지정:

  multi-byte 객체는 (거의 모든 시스템에서) 연속된 바이트에 저장되며, 객체의 주소는 사용된
  바이트의 최소 주소를 갖는다.

  어떤 데이터의 값이 커서 여러 바이트에 걸쳐 저장된 경우, 예를들어 1000번, 1001번, 1002번
  byte에 걸쳐 저장된 경우 이 객체의 주소값은 1000번으로 한다는 의미다.

- 바이트 순서:

  멀티바이트 객체를 메모리에 저장할 때 항상 값이 그릇에 딱 맞는 크기는 아니다. 3개 바이트에 2.5개
  바이트 분량(실제로는 3바이트지만)의 데이터만 담을수도 있는 것이다. 이때 좌로 정렬, 우로정렬
  어디로 할 것이냐는 문제다. 단지 가장 중요한(시작부분) 바이트부터 저장할지 덜 중요한(끝부분)
  바이트부터 저장할지 차인데, 대부분의 인텔 호환 프로세서들은 리틀 엔디안 방식(뒤에서부터)으로만
  동작한다. 

  두 가지는 구현의 차이지 논리적으로는 차이가 없다. 다만 관습이 있을 뿐이다.

  몇몇 경우에는 이 부분이 문제가 되기는 하는데, 첫째는 서로 다른 바이트 순서를 가진 두 시스템이
  네트워크 통신을 할 때이다. 이에 대비하여 네트워크 송신측은 표준 방식으로 전달하고, 수신측은 받은
  데이터를 자기 자신에 맞게 변환하도록 하도록 한다.

  두번째는 인간이 직접 기계수준의 코드를 살펴볼 때이다. 사람이 눈으로 직접 보기 때문에 좌에서 우로 읽을지
  우에서 좌로 읽을지 당연히 알고 읽어야한다.

  세번째는 C언어의 cast나 union을 사용할 때다. 이것의 의미는 '같은 메모리 공간을 여러 타입으로
  해석'하는 것인데 이때 바이트 순서가 어느 방식이냐에 따라 저장된 값의 해석이 달라질 수 있다.

  한편 운영체제는 이 부분에 대하여 하드웨어의 요구사항에 맞춰야 한다.



#### 더 알아가기(코어타임에서 배운것)

1. ~컴퓨터의 산술연산은 모두 덧셈으로만 이루어진다.~ ==> 덧셈과 보수, 시프트 연산 등으로 구현할 수 있다.

  - 2의 보수를 활용해서 뺄셈도 덧셈으로 해 버린다.
  - 곱셈 나눗셈도 결국 여러번 더하거나 여러번 빼는 것이므로 마찬가지다.

    ```md
    # 예시: 7 - 5 (4비트 연산)

    1. 5의 2의 보수 구하기: 1010 + 1 = 1011
       (1의 보수는 각 비트 반전)
       (2의 보수는 각 비트 반전 + 1)

    2. 7 + 5의 2의 보수:
       7 = 0111
       0111 + 1011 = 10010
    3. 결과(5비트)에서 오버플로우(첫 번째 1) 무시: 0010
    4. 0010 = 2 (정답)
    ```


2. 부동소수점의 경우 (대부분)근사값을 가진다.

  - 컴퓨터의 실수 표현 정확성의 한계는 실수와 실수 사이에는 무한한 가지수의 실수가
    존재한다는 점에 기인한다.
    - 유한한 비트로 무한한 실수를 표현하는 것이 애초에 불가능하다.

  - 단, 2의 거듭제곱으로 나눈 수(`x/2^n`)에 해당하는 실수는 정확히 표현할 수 있다.

    ```md
    - 0.1 (10진수)  
      0.1은 10진수로는 정확히 표현되지만,  
      2진수로는 무한소수(0.0001100110011... 반복)로 나타나서  
      컴퓨터의 부동소수점(유한 비트)에서는 근사값으로만 저장됩니다.

    - 0.25 (10진수)  
      0.25는 2진수로 0.01이므로,  
      이진 부동소수점에서 정확하게 표현할 수 있습니다.
    ```

  - 다만 표현을 정확히 할 수 있는 실수끼리도 연산을 하게되면 오차는 발생한다. 연산과정에서
    정확히 표현할 수 없는 실수가 나타나기 때문.


3. 비트연산

  - `<<` 또는 `>>` 기로를 사용하여 shift, unshift연산이라 하는데 비트를 옆으로 밀어버린다.

    예를들어 0001 4비트 가있다면 `<<` 연산으로 0010을 만들어 버린다. 반대 방향도 가능하다.

    한편 예시의 4비트에서 연산 후 결과인 0010에 가장 우측 0은 어디서 나타난 것일까? 실제로는 바로
    우측에 있던 비트가 넘어온 것이다. 이러면 연산의 결과가 오염되기 때문에 우리는 padding(0을
    넣어 덮어씌우기)을 해 주는 것이다.

    음수의 다만 해당 비트의 머리에 음수 표현이 있는 경우 언어마다 지원 여부가 다르지만 부호를
    보존하는 연산이 별도로 있거나 자동으로 부호를 보존하도록 하는 경우들이 있다.



## (팀)코어타임 기록



### 1차

지난 주차와는 시작부터 분위기가 사뭇 달랐다. 익화님은 아주 기세가 좋으신것같다. 나도 똑같이
하기는 어렵거나 안좋을수도 있지만 기회가 되는만큼 어떻게 해가시나 들어보고 잘 배워보고싶다.

또 코어타임에 무엇을 나누는지도 되게 달랐다. 지난번은 각자나 누군가가 이해한 바를 공유(자신있거나
없어도 그냥 한번 해보거나)하면 그것을 서로 바로잡거나 의문을 가지거나, 모호한 부분을 발견해보는
식이었다. 그런데 오늘은, 특히 익화님은 자신이 공부한 것에서 중요하다고 생각한 부분을 아주 명확히
짚어서 발표(?) 준비를 해 와 주셨다.

덕분에 나는 생각지도 못하게 많이 배웠다. 혼자했으면 주제나 키워드별로 한두줄로 핵심을 요약하기
위해 상당히 공을 들였어야 했을텐데, 그냥 날로 먹은 것 같다. 게다가 설명도 아주 명쾌하게 해주셔서
이해하기도 아주 쉬웠다.

하지만 너무 잘해주셔서 부담도 생겼다. 내가 너무 안일하게 생각했나 싶었다. 물론 나도 주어진
시간동안 최선을 다해 이해해보려고 하긴 했는데, 일단 내가 잘 이해하는 것에 치중했지 다른
팀원들에게 무엇을 나눠야하는지에 대해서는 거의 생각해보지 않았었다.
