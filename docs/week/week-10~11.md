# week-10~11: Pintos - User Program



> [!nt]
>
> 팀원: 김용환 + 유선목



> [!nt] how to 코어타임
>
>
> - 책은 개인적으로 보면서 같이 보고싶은게 있으면 자유롭게 제안하기
>
> - 원하는것:
>
>     - 용환: 이 과정이 잘 드러나는 결과물이 만들어지면 좋겠다. 일단 생각하는것은 블로그?
>     - 선목: 추상적으로 배워온 OS의 실제 모습을 보고싶다.
>     - 상연: - 70%: OS가 소프트웨어라는데 어떻게 생겼나 보고 알고싶다.
>             - 30%: 내 코드를 남이 이해하기 쉽게하고, 남의 코드를 잘 이해해보는 연습을 하는것
>
>
> 


> [!nt] PR 단위는 아래처럼
>
> - Project.1
> - Project.2-3
> - Project.4



> [!rf]
> 
> [team 레포](https://github.com/tjsahr9191/KJ-Pintos-7team)
> [나](https://github.com/greyHairChooseLife/KJ-Pintos-7team)



> [!rf]
> 
> [master gitbook](https://casys-kaist.github.io/pintos-kaist/)
> [totalOS.pdf _ Youngjin Kwon](file:./static/20240928-01_os_review.pdf)


> [!rf]
>
> [pitos P1](file:./static/Pintos_1.pdf)



## Operating System의 큰 흐름 이해하기

**TOC**

  - Flow of Interrupt
  - Flow of Scheduler
  - Flow of Thread


### (PintOS) 인터럽트 처리 흐름


**전체 흐름**

  1. 유저/커널 모드에서 인터럽트 발생
  2. CPU가 커널 스택에 컨텍스트(RIP 등) 저장, 커널 모드로 전환
  3. 인터럽트 벡터에 등록된 stub 함수 진입
  4. stub에서 intr_entry로 점프
  5. intr_entry에서 레지스터 저장 및 세그먼트 설정
  6. intr_handler에서 인터럽트 처리
  7. intr_entry에서 레지스터 복구
  8. iretq로 원래 실행 위치 및 모드 복구, 프로그램 실행 재개



- 참고

    - 일반 레지스터: 직접 복구 (movq 등)
    - 실행 위치 및 모드: iretq가 자동 복구
    - 커널 스택 사용: 항상 커널 영역에 컨텍스트 저장, 유저 스택 사용하지 않음
        - 유저 프로세스 실행중에는 TSS를 활용하여 해당 쓰레드의 TCB 스택 영역을 활용할 수 있도록 관리
        - 인터럽트, 시스템콜로 인해 사용된 이 TCB 커널스택 영역은 각 핸들러의 반환과 함께 항상
          스택프레임이 정리된다.


#### x86_64 TSS(Task State Segment)와 커널 스택 관리

```c
struct task_state {
    uint32_t res1;
    uint64_t rsp0;
    uint64_t rsp1;
    uint64_t rsp2;
    uint64_t res2;
    uint64_t ist1;
    uint64_t ist2;
    uint64_t ist3;
    uint64_t ist4;
    uint64_t ist5;
    uint64_t ist6;
    uint64_t ist7;
    uint64_t res3;
    uint16_t res4;
    uint16_t iomb;
} __attribute__((packed));
```

- **TSS(Task State Segment) 구조**
  - x86_64에서 태스크 전환 및 예외 처리를 위해 사용되는 특수한 데이터 구조.
  - 주요 멤버:
    - `rsp0`: 유저 모드에서 커널 모드로 전환 시 사용할 커널 스택의 최상단 주소.
    - `rsp1`, `rsp2`: CPL 1, 2에서 사용할 스택 포인터(대부분의 OS에서는 사용하지 않음).
    - `ist1`~`ist7`: Interrupt Stack Table. 특정 치명적 예외(NMI, double fault 등) 발생 시 사용할 별도의 스택 주소.
    - `iomb`: I/O 권한 비트맵의 시작 위치. 각 태스크별로 I/O 포트 접근 권한을 제어할 수 있음.
    - 그 외 필드는 대부분 예약(reserved) 용도로, 구조의 정렬이나 확장성을 위해 존재.

- **커널 스택 관리**
  - 각 태스크(TCB)는 고유의 커널 스택 영역을 가짐.
  - 인터럽트나 시스템콜 발생 시, CPU가 TSS의 `rsp0` 값을 스택 포인터로 로드하여 안전하게 커널 스택을 사용.
  - 커널에서 작업이 끝나면 스택 프레임이 정리되어, 다음 진입 시 다시 `rsp0`에서 시작할 수 있도록 준비됨.
  - 커널 스택이 손상되거나 오염될 위험이 있는 특별한 예외 상황에서는 IST에 지정된 별도의 스택을 사용.

- **I/O 권한 관리**
  - TSS의 I/O 권한 비트맵(`iomb`)을 통해 각 태스크별로 특정 I/O 포트 접근을 허용하거나 제한 가능.
  - 일반적으로 유저 프로세스는 직접 I/O 접근이 제한되고, 커널이나 드라이버만 허용됨.

- **요약**
  - TSS는 태스크별 안전한 스택 전환과 예외 처리를 위한 핵심 구조.
  - 커널 스택은 항상 `rsp0`에서 시작하며, 반환 시 원래 위치로 복구됨.
  - 특별한 예외 상황에서는 IST 스택을 사용하여 시스템 안정성을 확보.
  - I/O 권한 비트맵으로 프로세스별 I/O 접근 제어가 가능.




#### 흐름 상세 설명

##### 인터럽트 발생 시 컨텍스트 저장

- CPU가 자동으로 커널 스택에 아래 값 저장  
  - RIP (명령어 포인터)  
  - CS (코드 세그먼트)  
  - RFLAGS (플래그 레지스터)  
  - RSP, SS (유저 모드 → 커널 모드 전환 시)
- 커널 스택은 해당 쓰레드의 TCB에 연결된 영역

##### 인터럽트 벡터와 진입점

- 인터럽트 벡터(0~255): 각 번호별로 진입점 함수(stub) 등록
- STUB 매크로: 각 벡터에 대응하는 intrXX_stub 함수 생성
- intr_stubs 배열: 각 stub 함수의 주소 저장, 커널 초기화 시 IDT에 등록

##### stub 함수 역할

- 인터럽트 발생 시 필요한 정보(프레임 포인터, 에러 코드, 벡터 번호) 스택에 푸시
- intr_entry로 점프

##### intr_entry 함수 동작

- 일반 레지스터(rax, rbx, rcx, ... r15 등)와 세그먼트 레지스터(ds, es) 커널 스택에 저장
- 세그먼트 레지스터(ds, es, ss, fs, gs) 커널 데이터 세그먼트로 설정
- intr_handler 호출 (실제 인터럽트 처리)
- 핸들러 종료 후, 저장해둔 레지스터 값 복구

##### iretq 명령어

- 스택에 저장된 RIP, CS, RFLAGS, RSP, SS 복구
- 원래 실행 위치(유저/커널 모드)로 복귀, RIP가 가리키는 명령어부터 실행 재개


