# Representation of Programs



[notebookLM](https://notebooklm.google.com/notebook/f405095d-572f-4992-bf85-e8781645f33a)


- **이 챕터의 목표:**

  C와 같은 고급 언어로 작성된 프로그램이 컴퓨터에서 실제로 어떻게 기계어(machine code)로 표현되고
  실행되는지를 이해하는 것이다.

    - 컴파일러의 최적화 능력을 파악하고
    - 프로그램의 잠재적 비효율성을 분석하며
    - 시스템 해킹과 같은 보안 취약점이 어떻게 발생하는지


- 목차

  1. Historical Perspective
  2. Program Encodings
  3. Data Formats
  4. Accessing Information
  5. Arithmetic and Logical Operations
  6. Control Flow
  7. Procedures
  8. Array Allocation and Access
  9. Heterogeneous Data Structures
  10. Combining Control and Data
  11. Floating-Point Code
  ~12. Summary~



## 기초     :  기계어의 본질과 표현

_기계어 프로그램을 본격적으로 분석하기 전에,
필요한 배경지식과 기본적인 개념을 소개합니다._

목표: 
  - 기계어는 궁극적으로 바이트(byte)의 연속일 뿐임을 이해함
  - 어셈블리 코드(assembly code)를 분석하는 것이 기계어를 이해하는 핵심적인 방법임을 알게됨

### Historical Perspective

- x86 계열의 진화와 하위호환성

  - 프로세서의 발전은 메모리 사용 방식, 인스트럭션 추가, 하이퍼쓰레딩 및 멀티코어 기술 적용
  - 점진적으로 개선되었고, 관련 소프트웨어도 있으니 하위호환성 지원
  - 따라서 용어의 혼재 및 하위호환성을 위해서만 존재하는 요소들이 있음


### Program Encodings


- 컴파일 시 최적화 단계를 지정할 수 있음
  - 컴파일 소요시간 대비 프로그램 성능 다름
  - 너무 높은 수준의 최적화는 디버깅을 어렵게 함


- 어셈블리 코드를 이해할 수 있고, 본래 C코드와 어떻게 연관되었는지 이해하는 것이 중요함

  - C언어와 기계어의 차이

    1. C언어에서는 프로세서 상태가 감추어져 있음
        - _프로그램 카운터 (%rip):_ 다음에 실행할 명령어의 주소를 가리킨다.
        - _정수 레지스터 파일:_ 주소(포인터)나 정수 데이터를 저장한다.
        - _조건 코드 레지스터:_ 연산 결과의 상태를 저장한다.
        - _벡터 레지스터:_ 여러 개의 정수/부동소수점 값을 저장한다.

    2. 기계어는 여러가지 종류의 데이터 타입(int, double, signed unsigned 등등)을 구분하지 않음
    3. 메모리를 바라보는 관점의 차이
       - C 언어: 추상화되어있으며, 자기 프로그램만의 공간을 상정함(가상 메모리 안에 소스코드, 힙, 스택 등)
       - 기계어: 그냥 거대한 바이트 덩어리와 접근할 수 있는 주소. 어떻게 해석할지 컨텍스트가 중요함

    4. 기계어는 그냥 바이트의 나열일 뿐
       - 이 바이트들은 1~15(x86의 경우)바이트 길이로 개별적인 인스트럭션들의 나열이다.



## 핵심 요소:  데이터와 연산


_기계어의 기본 구조를 이해했다면,
이제 프로그램의 가장 기본적인 두 요소인 '데이터'와 '연산'이 기계 수준에서 어떻게 다뤄지는지
학습합니다._


목표:

  - C코드 한 줄이 여러 개의 기계어 명령어로 번역될 수 있음을 알게됨
  - 특히 leaq 명령어처럼 주소 계산 명령어가 일반 산술 연산에 최적화되어 사용되는 흥미로운 사례를
    통해 컴파일러의 최적화 기법을 엿봄

### Data Formats

- C의 데이터 타입(int, char, 포인터 등) 마다 차지하는 바이트 수가 있고, 이것은 어셈블리어로
  번역된 코드에 나타나있다.

  _(어샘블리어 코드를 보면)_
  1. 인스트럭션의 나열이다.
  1. 인스트럭션에는 operand의 크기를 나타내는 접미어가 있다. (p.171 그림 3.1)
     - `b,w, l, q, ...등`

     - compile단계에서 생성된 어샘블리어 코드에서는 이 크기를 나타내준다.
     - 디버거나 objdump 따위로 생성한 역어샘블러 코드는 이것을 생략한 경우가 많다. 오퍼렌드 값을
       보고 쉽게 데이터 크기를 추측할 수 있기 때문이다.
       또는 동일한 이유로 정반대인 경우도 있다.
      
  1. 각 인스트럭션은 1~15B
  1. compile 단계에서 미완성된 부분을 링커가 채워준다. 어셈블러와 링커를 위한 지시문이
     있다.(`.`으 로시작함)


- 성능 등을 이유로 어셈블리어 코드를 직접 C언어 코드에 포함할수도 있다.
  - inline으로 넣을수도 있고, asm파일을 함수단위로 만들어서 링커에게 연결하도록 할수 있다.
  - 근데 그러면 특정 아키텍쳐에 국한되어 실행되는 기능이기 때문에 제한적으로 사용해야한다.


### Accessing Information


#### 범용 레지스터

**레지스터의 명명과 접근:**

- 정수값과 주소값이 저장
- 역사적 맥락에 따라 16b, 32b, 64b 시스템에서 다뤄지는 각각의 레지스터 capacity도 커지고,
  이에 따라 이름도 확장
- 개발자는 이 영역들중 무엇에 접근할지 선택

- 16개 범용 레지스터 (p.173 그림 3.2)


> [!qt]  64비트 시스템에서 작은 레지스터 이름을 사용하는 이유
>   󱞪 단순히 과거의 유산이 아니라, 다양한 데이터를 효율적으로 다루고 코드를 최적화하기 위해
>
>   - 데이터 타입 크기에 맞는 효율적 연산:
>     C언어의 int(4바이트), short(2바이트), char(1바이트) 등 다양한 크기의 데이터를 처리할 때, 그
>     크기에 딱 맞는 레지스터 이름(%eax, %ax, %al)과 명령어를 사용하면 더 빠르고 효율적입니다.
>   
>   - 하위 호환성 및 명령어 구조:
>     x86 아키텍처는 16비트에서 64비트로 점진적으로 확장되었습니다. 과거 버전과의 호환성을 위해
>     기존의 레지스터 접근 방식을 유지하고 있습니다.



**레지스터의 역할:**

대부분의 레지스터는 유연하게 사용될 수 있지만, 몇몇은 특별한 역할

- `스택 포인터(%rsp)`는 런타임 스택의 끝을 가리키는 매우 중요한 역할. 가장 최근 시점을
  뜻한다.(최근에 데이터가 저장되었다거나)
- 함수 인자 전달, 반환 값 저장, 지역 변수 및 임시 데이터 저장 등에 사용되며, 이는 표준
  프로그래밍 관습에 따름


#### 피연산자 지정 방식 (Operand Specifiers)

_대부분의 명령어는 연산에 사용할 소스(source) 값과 결과를 저장할 목적지(destination)를 지정하는
하나 이상의 피연산자를 가진다._

예시)
```asm
movq %rax, %rbx      # %rax의 값(숫자 또는 주소)을 %rbx에 복사
movq (%rax), %rbx    # %rax가 가리키는 메모리의 값을 %rbx에 복사
```


- x86-64에서는 세 가지 유형의 피연산자를 지원

  - 즉시값(Immediate): 상수 값
  - 레지스터(Register): 레지스터에 저장된 내용. 16개 레지스터의 하위 1, 2, 4, 8바이트 부분을
    피연산자로 사용
  - 메모리 참조(Memory Reference): 계산된 주소(유효 주소)를 통해 메모리 위치에 접근



- operand 괄호의 의미

  - 괄호가 없는 경우:
    레지스터에 들어있는 **값 자체**를 의미
    (그 값이 주소이든, 숫자이든, 그냥 그 값 자체를 사용)

  - 괄호가 있는 경우:
    레지스터에 들어있는 값을 **메모리 주소로 사용**해서,  
    그 주소에 저장된 **메모리의 실제 값**



#### 데이터 이동 명령어 (Data Movement Instructions)

_데이터를 한 위치에서 다른 위치로 복사하는 명령어는 프로그램에서 가장 빈번하게 사용되는 명령어
중 하나_


- `MOV`: 데이터 이동 명령어

  - 메모리 <=> 레지스터 간 복사만 허용
  - movb/w/l/q는 크기별
  - movabsq는 64비트 즉시값 이동


- `MOVZ/MOVS`: 작은 크기 => 큰 크기 복사

  - `movz`: 제로 확장
    (작은 크기의 값을 더 큰 크기의 레지스터로 옮길 때 남는 상위 비트(앞부분)를 0으로 채워서 저장)
  - `movs`: 부호 확장
    원래 값의 부호(음수/양수)를 유지하기 위해 남는 상위 비트(앞부분)를 값의 최상위 비트(부호
    비트)로 채워서 저장
  - `movl`: 상위 4바이트 0으로 채움
  - `cltq`: `%eax` => `%rax` 부호 확장


- `PUSH/POP`: 스택에 데이터 저장/복원

  _stack 영역은 상위 주소부터 사용하여 점점 아래로 뻗어나간다. 컨텍스트가 깊어질수록 더 낮은
  주소영역을 사용하고, 개별 컨텍스트에서 시작점은 최상단이다._

  _stack 영역의 가장 오래된 지점을 stack bottom, 최근 시점을 stack top이라 부른다. 그러니까
  스택포인터 레지스터(`%rsp`)는 항상 stack top이 되는거다._

  - 저장 또는 제거되는 데이터의 크기만큼 스택포인터(`%rsp`)가 이동한다.

    - pushq: 더 낮은 주소값으로 이동
    - popq : 위치 더 높은 주소값으로 이동


### Arithmetic and Logical Operations


_정수 값과 논리 값을 계산하는 데 사용하는 주요 명령어_


- **주소 계산 (Load Effective Address - `leaq`)**
  - 유효 메모리 주소를 계산하여 레지스터에 저장
  - 근데 메모리 주소 계산에만 사용하지 않고 일부 산술연산에 사용한다. 제한된 경우지만 효율이 좋다.

  - ex)
  ```asm
  leaq 8(%rbp), %rax      # %rbp + 8의 값을 %rax에 저장 (메모리 접근 X, 단순 계산)
  ```



- **단항 및 이항 연산 (Unary and Binary Operations)**

  - 단항 연산: 

    - `inc`: 증가
    - `dec`: 감소
    - `neg`: 부호 반전

    - ex)
    ```asm
    inc %rax                ## %rax 값을 1 증가
    dec %rbx                ## %rbx 값을 1 감소
    neg %rcx                ## %rcx 값을 부호 반전 (양수→음수, 음수→양수)
    ```


  - 이항 연산: 두 개의 피연산자를 받아 연산을 수행하고, 결과를 두 번째 피연산자에 저장

    - `add `: 덧셈
    - `sub` : 뺄셈
    - `imul` : 곱셈
    - `xor, or, and` : 논리 연산

    - ex)
    ```asm
    add %rbx, %rax          # %rax = %rax + %rbx
    sub %rcx, %rdx          # %rdx = %rdx - %rcx
    imul %rbx, %rax         # %rax = %rax * %rbx
    xor %rcx, %rdx          # %rdx = %rdx XOR %rcx
    or  %rbx, %rax          # %rax = %rax OR %rbx
    and %rcx, %rbx          # %rbx = %rbx AND %rcx
    ```


- **시프트 연산 (Shift Operations)**
  - 데이터의 비트를 왼쪽 또는 오른쪽으로 이동
  - 논리적 오른쪽 시프트 (`shr`): 왼쪽을  0으로 채움 (부호 없는 수에 사용)
  - 산술적 오른쪽 시프트 (`sar`): 왼쪽을 최상위 비트(부호 비트)로 채움 (부호 있는 수에 사용)
  - 왼쪽 시프트 (`sal 또는 shl`): 두 가지 이름이 있지만 기능은 동일

  - ex)
  ```asm
  shr $1, %rax            # %rax를 오른쪽으로 1비트 논리 시프트 (부호 없는 수)
  sar $1, %rbx            # %rbx를 오른쪽으로 1비트 산술 시프트 (부호 있는 수)
  shl $2, %rcx            # %rcx를 왼쪽으로 2비트 시프트 (sal도 동일)
  ```



- **특수 산술 연산 (Special Arithmetic Operations)**

  - 64비트 곱셈은 128비트 결과를 낸다.
    - `imulq` (부호 있음)
    - `mulq` (부호 없음)
    - 결과는 %rdx와 %rax 두 레지스터에 나뉘어 저장

  - 128비트 값을 64비트 값으로 나누는 나눗셈과 나머지 연산
    - `idivq` (부호 있음)
    - `divq` (부호 없음)

  - ex)
  ```asm
  imulq %rbx              # %rax = %rax * %rbx (128비트 결과: %rdx:%rax)
  mulq %rbx               # %rax = %rax * %rbx (부호 없음, 128비트 결과: %rdx:%rax)

  # %rdx:%rax를 %rbx로 나눔, 몫은 %rax, 나머지는 %rdx
  idivq %rbx              # 부호 있음
  divq %rbx               # 부호 없음
  ```




## 핵심 요소:  프로그램의 흐름 제어

_데이터를 조작하는 방법을 배웠으니,
이제 프로그램의 실행 흐름을 바꾸는 C의 제어 구조(if, switch, for, 함수 호출 등)가 어떻게 구현되는지
알아봅니다._

목표:

  - C에는 존재하는 반복문이나 조건문이 기계어에는 없다는 사실을 이해

    - 모든 제어 흐름은 "특정 조건을 검사해서 다른 곳으로 점프할지, 아니면 다음 명령어를 실행할지"
      결정하는 단순한 메커니즘으로 귀결
    - 특히 switch문이 점프 테이블(jump table)이라는 효율적인 자료구조로 구현되는 방식을 통해 성능
      최적화 기법을 깊이 있게 이해

  - 스택 프레임(stack frame)이라는 개념을 통해 각각의 함수 호출이 독립적인 공간을 가지게 되며, 이를
    통해 재귀 호출(recursion)도 가능해짐

  - 버퍼 오버플로우 공격이 스택에 저장된 반환 주소를 변조하여 발생한다는 것을 이해하는 기반을 닦음


### Control Flow


> _C언어가 직관적이고 추상적인 제어구조를 표현하지만, 기계어로 변환되면 '주로' 원시적인 두 가지
> 메커니즘에 의존함_
>
> 1. 데이터 값 테스트: 데이터 값을 테스트
> 2. 제어 흐름 변경: 설정된 조건 코드를 바탕으로 점프(`jump`) 명령어를 사용하여 프로그램의 실행
>    흐름을 변경
>    (다른것도 있긴 하다)


#### Condition Codes

- 주로 `cmp`(비교), `test`(특정 비트 테스트) 명령어

- **직전 연산** 결과의 속성을 **조건 코드(condition code)**라는 특정 레지스터에 1비트씩 저장됨

  | Flag |          이름 | 설명                    |
  |------|--------------:|-------------------------|
  | `ZF` |     Zero flag | 연산 값이 0인지 여부    |
  | `SF` |     Sign flag | 연산 값이 음수인지 여부 |
  | `OF` | Overflow flag | signed overflow 여부    |
  | `CF` |    Carry flag | unsigned overflow 여부  |


#### Accessing Condition Codes


_조건코드를 아래의 방식들로 상용함_


1. `SET` 

  조건을 값으로 변환하여 레지스터에 저장 



2. `JUMP`

  `Condition Code`를 확인하여 실행 흐름을 분기. 조건이 부합하면 프로그램 카운터(`%rip`)에
  다른 주소값을 할당. if-else, while, for 등에서 사용한다.



3. `CMOV`(**Conditional Move**, 조건부 데이터 선택)


  - 현대 프로세서의 성능 최적화를 위해 도입된 고급 제어 방식
  - 점프를 사용하지 않고, 조건 코드에 따라 소스 피연산자의 값을 목적지 레지스터로 복사할지 여부를 결정

  - jump방식과의 차이
    - jump(전통적) 방식: **분기 예측이 실패할 경우** 큰 성능 저하
    - 조건부 데이터 선택 방식: if/else 양쪽 결과 모두 계산, 조건 코드에 따라 cmov 명령어로 올바른 결과값만 최종 선택
    - 양쪽 결과를 모두 계산하는 비용이 단점이라, 간단한 연산에 사용

    > [!qt] 왜 분기를 예측 하는가?
    >    
    > - 현대 프로세서는 높은 성능을 위해 Pipelining 기술을 사용
    > - 파이프라이닝: 하나의 명령어를 실행하는 과정을 여러 단계로 나누고, 각 단계를 동시에 처리
    >   (예: 명령어 가져오기, 명령어 해석, 데이터 읽기, 연산 수행, 결과 저장 등)
    > - 파이프라인이 계속 가득차 있어야 프로세서는 최대 성능
    > - 그래서 if-else, while 등 조건부 점프를 만나도 일단 예측하여 파이프라인을 채움(== 분기예측)
    > - 만약 예측에 실패하면 15~30클럭 사이클의 성능저하(통상 연산 1회에 1클럭)
    >   (현대 프로세서는 약 90% 예측 성공)



  - **제어의 흐름(control flow)을 데이터의 흐름(data flow)으로 변환**하는 대표적인 예

    > - 제어 흐름(Control Flow):  
    >
    >   if/else, for, while, goto, jump 등 **분기(branch)** 명령어로 프로그램의 실행 경로가 달라짐  
    >
    >   ```
    >   # 이 코드는 내부적으로 분기(jump) 명령어를 사용함
    >   
    >   if (cond) {
    >       x = a;
    >   } else {
    >       x = b;
    >   }
    >   ```
    >
    >
    > - 데이터 흐름(Data Flow):  
    >
    >   분기하지 않고, **모든 데이터를 계산한 뒤 조건에 따라 필요한 값만 선택**  
    >   ```
    >   x = cond ? a : b;
    >   ```
    >
    >   또는, 어셈블리에서 `cmov` 명령어로  
    >   - a, b 모두 계산  
    >   - cond가 참이면 a를, 거짓이면 b를 x에 복사




#### Jump Instructions


**점프의 두 가지 방식**

  1. 무조건 점프 `jmp`: 지정된 레이블(주소)로 프로그램의 PC(`%rip`)를 즉시 이동
  2. 조건부 점프 `je, jg 등`: 조건 코드에 따라 점프 여부 결정




**분기예측**

- 최적화 위해 파이프라이닝 기법
- 단, 예측 실패시 패널티 큼(현대는 90% 이상 적중)
- 이에 대응하여 cmov 같이 여러 경우를 모두 계산해버리기도 함(단, 비용 고려해야함)




**점프(`jump`) 명령의 인코딩**

- jump는 곧 PC(`%rip`)의 수정
- 대부분의 jump명령은 상대주소(relative addressing)를 지정함

  - 상대주소 방식: instruction의 절대값 주소 대신 (순차적으로 볼 때)직후 pc로부터의 상대적 offset을 기록
  - 왜? 
    - 가까운 거리를 점프할 때는 1~2B로 표현가능
    - 재배치 가능성(relocatability): 링커가 하나의 실행파일 만들 때 여러 코드블록 주소가
      바뀔 수있음. 이때에도 별도로 수정하지 않아도 되니까.

    > [!qt] 왜 직후 pc값을 offset 기준으로 삼을까?
    >   󱞪 과거엔 processor가 인스트럭션을 실행할 때 첫번째 단계가 프로그램 카운터를 갱신했다.
  

- 어샘블리 코드에서 jump 목적지는 레이블(Lable)로 표시함
  ````asm
      CMP AX, BX
      JE  .L2         ; 같으면 .L2로 점프
      JG  .L3         ; 크면 .L3로 점프
      JL  .L4         ; 작으면 .L4로 점프

  .L2:
      ; AX == BX일 때 실행
      JMP .L5
  .L3:
      ; AX > BX일 때 실행
      JMP .L5
  .L4:
      ; AX < BX일 때 실행
  .L5:
      ; 공통 종료 지점
  ````


#### Implementing Conditional Branches & Conditional Data Transfers

_- 기계어 코드는 단순히 C 코드를 일대일로 번역한 것이 아님_
_- 하나의 소스코드가 다양한 결과물로 나타날 수 있음_
_- 컴파일러는 프로세서에 따라 C 코드의 구조와는 다른 방식으로 코드를 재구성하여 성능을 극대화_


- 제어흐름은 아래의 두 가지 방식으로 조절됨

  1. 조건부 제어 이동: 전통적인 방식으로, `conditoin code`와 `jump`를 이용
  2. 조건부 데이터 이동: 현대 프로세서의 분기예측 성능 특성을 고려한 최적화



- > [!nt] 조건부 데이터 이동의 한계
  >
  >  모든 경우에 사용할 수 없다.
  >
  >  가장 중요한 한계는 양쪽 경로를 모두 평가하기 때문에 발생할 수 있는 부작용, 오류이다.
  >
  >  예를 들어, cread 함수(return (xp ? *xp : 0);)를 조건부 이동으로 구현하면, xp가 널 포인터일
  >  때도 *xp를 역참조하려는 시도가 발생하여 오류를 이르킨다. 이처럼 유효하지 않은 메모리 접근이나 값을
  >  변경하는 부작용이 있는 경우에는 반드시 전통적인 조건부 제어 이동(점프)을 사용해야 한다.




#### Loops


_- 고급 언어 수준에서의 다양한 추상화가 기계어 수준에서 단순화됨_
_- 컴파일러의 최적화 전략을 이해하고 있는것이 중요함_
_- 역엔지니어링의 중요성(내가 짠 코드와 다른 결과물이 나옴)_


> "반복문 또한 조건부 분기 메커니즘을 응용하여 구현되는 제어 흐름일 뿐"
> 
>   1. 루프 본문 실행          _<= 이놈이 추가되었을 뿐, 기본 양상이 같다._
>   2. 조건 테스트(cmp, test)
>   3. jump




1. **do-while Loop**

  - 루프 본문 실행
  - 조건 테스트
  - jump



2. **while Loop**

  루프 본문 실행 전에 조건을 먼저 테스트. _두 가지_ 전략이 있다.

  - Jump-to-Middle:
    - 낮은 최적화 레벨(-Og)에서 사용
    - 루프 시작 전에 무조건 점프(jmp)를 사용하여 루프의 끝에 있는 테스트 코드로 이동

  - Guarded-Do:
    - 높은 최적화 레벨(-O1)에서 사용
    - 루프에 진입하기 전에 먼저 조건을 검사하는 '가드(guard)'를 둠
      - 조건이 거짓이면 조건부 점프를 통해 루프 전체를 건너뜀 
      - 조건이 참이면, 이후의 루프는 do-while 루프와 동일한 구조로 실행
      - 컴파일러는 이 과정에서 루프 조건을 최적화



3. **for Loop** 

  - for 루프를 먼저 while 루프 형태로 변환
  - while 루프 번역 전략 중 하나를 적용




4. **switch**

  _- 제어 흐름이 어떻게 데이터 구조와 영리하게 결합하여 효율성을 극대화하는지를 보여주는 사례_
  _- if-else의 연속으로 인코딩 될 수도 있고, 다른 방식일수도 있고 컴파일러가 판단한다._

  - jump table의 활용
    - case마다 실행해야할 구문의 주소값이 들어있음
  - case 조건에 따라 계산된 인덱스를 사용하여 jump table 배열에서 인덱싱
  - case 숫자와 실행시간이 무관함



### Procedures



> [!nt] Procedure 메커니즘 이해의 중요성
>
> - **성능 최적화**: 함수 호출에는 스택 조작, 레지스터 저장 등 오버헤드가 발생하므로, 이를
>   이해하면 인라인 확장 등 컴파일러 최적화의 필요성과 성능에 민감한 코드에서 함수 호출 관리
>   방법을 알 수 있습니다.
>
> - **보안 취약점**: 함수 호출 시 스택에 저장되는 반환 주소와 지역 변수의 구조를 이해하면, 버퍼
>   오버플로우 같은 보안 취약점의 원인과 스택 보호 기법의 동작 원리를 파악할 수 있습니다.
>
> - **디버깅 및 리버스 엔지니어링**: 함수 호출의 기계 수준 동작을 알면, 디버깅 도구(gdb 등)로
>   스택 프레임을 분석해 오류 원인을 효과적으로 추적할 수 있습니다.


_고급 언어에서는 단순히 함수를 호출하고 값을 반환받지만,
기계 수준에서는 일련의 정교한 메커니즘이 필요하다._





#### Run-Time Stack

_프로세스 런타임에 수많은 함수들이 연쇄적으로 실행 및 종료된다. 이들의 컨텍스트(함수프레임 또는
스택프레임)는 가상주소공간의 Stack영역에 쌓이는데, "**이 영역 전체 (==자료구조)**"를 런타임 스택이라고 부른다._

_함수는 다른 함수를 호출하기 마련이라 컨텍스트는 깊어지는데, 각 컨텍스트는 독립적이어야하고,
하위 컨텍스트가 종료된 후엔 직전 레이어의 컨텍스트가 재개되어야 한다._



- 각 Procedure는 자신만의 **독립적인 영역**인 스택 프레임(함수 프레임)을 할당 받음

- **Procedure의 생명주기**

  1. 프로시저 _호출 시_ (제어 및 데이터 전달)

     > - 반환 주소 저장:
     >   - `call` 명령어를 통해 callee를 호출
     >     - `call` 명령은 아래를 수행함
     >       - 반환 주소(return address, `call` 명령어 바로 다음 명령어의 주소)가 스택에 푸시(`push`)
     >       - PC(`%rip`)가 callee의 시작주소를 가리키도록 만듦
     >
     > - 인자전달:
     >   - 인자 6개를 레지스터를 통해 전달, 정해진 레지스터 리스트가 있음
     >   - 인자의 데이터 크기에 따라 하위 레지스터를 선택해 사용
     >   - 만약 32b 데이터를 저장할 경우 상위 32~61b의 영역은 0으로 채워짐(Zero-extension)
     >     - 상위비트의 쓰레기값 걱정 없음
     >     - 상위비트를 별도로 초기화하는 추가 명령어가 필요 없음
     >   - 더 필요하면 caller 자신의 스택 영역에 저장해서 전달



  2. 프로시저 _실행 중_ (지역 저장 공간)

     > - 레지스터 상태 보존: caller가 사용하던 레지스터 값을 보존하기 위해 약속된 규칙
     >   - pro-logue 코드의 실행내용에 포함됨
     >
     >     - caller-saved: caller가 보존 책임
     >       - `%rax`, `%rcx`, `%rdx`, `%rsi`, `%rdi`, `%r8 ~ %r11`
     >     - callee-saved: callee가 보존 책임
     >       - `%rbx`, `%rbp`, `%r12 ~ %r15`
     >
     >   - 제어권을 돌려주기 직전에 각 레지스터에 값을 복원
     >
     >     - epi-logue 코드의 실행내용에 포함됨
     >     - 이 작업은 `ret` 인스트럭션 실행 직전에 완료됨
     >
     >
     > - 지역변수 할당: 
     >
     >   - 기본적으로 레지스터를 사용하지만 아래의 경우 스택을 사용
     >     - 레지스터가 부족할 때
     >     - 주소를 가져야 할 때(주소값으로 접근, 프로그래머가 &연산자를 사용)
     >     - 배열이나 구조체 변수를 사용할 때
     >
     >   - 스택 포인터(`%rsp`)를 필요한 만큼 아래로 이동(확장)



  3. 프로시저 _반환 시_ (제어/데이터 반환 및 메모리 해제)

     > * 반환 값 전달: 
     >   - 관례적으로 `%rax` 레지스터를 통해 caller에게 전달
     >     - 반환값이 32b 이하의 크기라면 `%rax`의 하위 레지스터로 전달
     >   - 경우에 따라 다를 수 있음
     >     - float, double은 `%xmm0`
     >     - 구조체 등 크기가 큰 경우 특별한 방법을 사용(후술)
     >
     > * 스택 프레임 해제:
     >   - 스택 포인터(`%rsp`)를 원래 위치로 되돌려 자신의 스택 프레임을 해제
     >     => 지역 변수 공간과 callee-saved 레지스터 저장 공간 등이 모두 소멸
     >
     > * 제어권 복귀:
     >   - `ret` 명령을 실행하면서, 자신(callee)의 스택프레임 가장 상위의 바로 위에 저장된
     >     반환주소를 PC(`%rip`)에 로드



#### 제어 전달 (Passing control)

- `call 명령`(반환주소 저장) 및 `ret 명령`(복귀)를 말함

- (런타임 스택 파트에서 이미 자세히 다뤘음)



#### 데이터 전달 (Passing data)

_* caller  ---> callee : **인자(arguments)** 전달_
_* caller <---  callee : **반환값(return value)** 돌려줌_

##### caller가 인자를 전달

- **레지스터를 통해 전달:** 

  - x86-64 아키텍처에서는 성능을 위해 가능한 레지스터를 통해 데이터를 전달
  - 최대 6개의 인자를 아래 표에 따라 순서와 데이터 크기를 고려하여 상위 또는 하위
    레지스터를 이용
    | 인자 순서 | **64비트** | **32비트** | **16비트** | **8비트** |
    |-----------|------------|------------|------------|-----------|
    | 1번째     | `%rdi`     | `%edi`     | `%di`      | `%dil`    |
    | 2번째     | `%rsi`     | `%esi`     | `%si`      | `%sil`    |
    | 3번째     | `%rdx`     | `%edx`     | `%dx`      | `%dl`     |
    | 4번째     | `%rcx`     | `%ecx`     | `%cx`      | `%cl`     |
    | 5번째     | `%r8`      | `%r8d`     | `%r8w`     | `%r8b`    |
    | 6번째     | `%r9`      | `%r9d`     | `%r9w`     | `%r9b`    |
     - 만약 32b 데이터를 저장할 경우 상위 32~61b의 영역은 0으로 채워짐(Zero-extension)
       - 상위비트의 쓰레기값 걱정 없음
       - 상위비트를 별도로 초기화하는 추가 명령어가 필요 없음



- **스택을 통해 전달:**

  - 6개를 초과하는 인자는 스택을 사용
  - caller는 호출 전에 추가 인자들을 _자신의 스택 프레임에 저장_
    - 이때 역순으로 push함. 즉 일곱 번째 인자를 마지막으로 스택에 담고 그 후 반환주소를 push

      > [!nt] 왜 역순으 로하냐?
      > 
      > - printf와 같은 가변 인자 함수(variadic function)를 효율적으로 지원하기 위해서
      >
      >   - 반환주소나 스택으로 전달하는 첫번째 인자는 따라서 항상 고정된 위치에 있다.
      >
      >     예를들어 가변길이 스택프레임이라면,
      >     %rbp+8에 반화주소가 있고, %rbp+16에는 7번째 인자가 있다.
      >
      >   - 이때 만약 스택에 저장된 첫번째 인자가 printf처럼 뒤에 따라올 인자들의 개수와
      >     정보를 포함하는 경우라면 컴파일러 입장에서 도움이 될 수 있다.


  - callee가 이전 스택프레임에 저장된 인자값에 액세스하기 위해 사용하는 offset은 두가지
    기준점을 사용

    > 1. 베이스 포인터(프레임 포인터) `%rbp`:
    >    - 전통적 방식
    >    - 제어권이 callee 함수 프레임으로 넘가면 먼저 prologue 코드를 실행하는데,
    >      이때 `movq %rsp, %rbp`같은 명령도 실행
    >    - 이 값은 고정된 기준점이 되어 arguments(상위 스택프레임) 및 지역변수에 접근하는
    >      기준점이 됨
    >
    > 2. 스택 포인터 `%rsp`:
    >    - 컴파일러가 판단하기에 callee가 고정된 길이의 스택 프레임을 사용한다면 %rsp도
    >      고정된 값이기 때문에 이것을 기준점 삼아 지역변수 및 인자에 접근
    >    - 이때 %rbp는 유휴상태이니 범용으로 활용하여 프로세스 성능 향상에 기여



##### callee가 반환값 전달
    

_- 관례적으로 `%rax` 레지스터를 통해 전달 (메모리보다 빠름)_
_- 단, 데이터 타입마다 이용하는 레지스터가 다를 수 있음_



- **`%rax`를 사용하는 경우:**

  - 64b 크기의 데이터인 경우: `%rax`
  - 작은 데이터 타입(int, char 등)의 경우: `%rax`의 하위 레지스터인 `%eax, %ax, %al`


- **다른 레지스터를 사용하는 경우:**

  - 부동소수점(float, double): `%xmm0`
  - 큰 구조체(Struct): 아예 다른 방식. 일반적으로 caller가 반환 값을 저장할 메모리 공간의
    주소를 **숨겨진** 첫 번째 인자로 전달, callee가 해당 주소에 직접 결과값을 채워 넣는 방식

    > [!nt] 정확히 어떻게 한다는거냐? 숨겨진 첫 번째 인자라니 뭔소리냐?
    >
    > (반환값이 레지스터 하나에 담을 수 없는 크기일 때)
    > 
    > 1. caller는 자신의 스택프레임에 미리 공간을 할당
    > 2. 이곳의 주소값을 마치 callee에게 전달하는 첫번째 인자인 것처럼 `%rdi`(인자 전달에
    >    사용하는 6개중 첫 번째)에 넣어둠
    >
    >    - 이렇듯 프로그래머가 명시적으로 전달한 인자가 아닌걸 전달하니까 **숨겨진** 인자라고 함
    >    - 명시적으로 전달하는 인자들은 2번째인 %rsi부터 이용됨
    >
    > 3. callee는 `%rdi`에 저장된 주소에 반환값으로 전달할 계산값들을 직접 복사함
    > 4. callee는 모든 연산이 종료되면 `%rdi`에 저장된, 반환값을 담아놓은 주소값을
    >    `%rax`에 담아줌
    >    
    >    - 굳이 %rax에 또 담아주는건 일관성을 유지하는것(규약을 지키는 것)
        


- 예시코드

  > - 고수준 코딩
  >   ```c
  >   int foo() {
  >     return 42;         // 32비트 정수 반환
  >   }
  >   
  >   long bar() {
  >     return 123456789L; // 64비트 정수 반환
  >   }
  >   
  >   int main() {
  >     int a = foo();
  >     long b = bar();
  >     return 0;
  >   }
  >   ```
  > 
  > - 인코딩 결과
  >   ```asm
  >   foo:
  >     mov     $42, %eax             # 32비트 정수 %eax로 반환
  >   
  >   bar:
  >     mov     $123456789, %rax      # 64비트 정수 %rax로 반환
  >   
  >   main:
  >     call    foo                   # foo() 호출
  >     mov     %eax, -4(%rbp)        # a에 반환값 저장
  >   
  >     call    bar                   # bar() 호출
  >     mov     %rax, -12(%rbp)       # b에 반환값 저장
  >   ```
  >
  >
  >  > [!qt] 예시에서 foo()의 반환값을 -4(%rbp)에 저장한 뒤, 왜 4B만큼이 아니라 8B만큼 더 아래에 bar()의 반환값을 저장할까?
  >  > 
  >  >   이것이 padding이다. 
  >  > 
  >  >   스택프레임의 정렬규칙과 관련 있는데, x86-64계열의 컴파일러는 스택 프레임의
  >  >   지역변수를 8B(64b) 단위로 정렬하려한다. 
  >  > 
  >  >   CPU가 8B 단위로 데이터를 읽고 쓰는 것이 더 빠르고, 일부 명령어는 8B 정렬이
  >  >   되어 있어야만 동작하기 때문




#### Local Storage on Stack


_프로시저 실행 중에만 필요한 지역 변수나 임시 데이터를 저장할 공간_


- **스택 프레임 할당:** 

  프로시저가 실행되는 동안 필요한 **지역 변수(local variables)**를 위한 메모리 공간을 확보하고,
  프로시저 종료 시 이를 해제하는 과정

  - 이 공간을 스택 프레임(또는 함수 프레임)이라고 함
  - 스택 포인터(`%rsp`)를 필요한 크기만큼 감소시켜서(스택은 낮은 주소로 자라므로) 확보

    이 프레임에는 아래를 저장

    - 지역 변수
    - 저장된 레지스터
    - 다른 함수에 전달할 인자 (후에 caller의 입장이 될 때)
    - callee 자신의 반환 주소 (후에 caller의 입장이 될 때)


    > 레지스터 저장 규칙:
    > 
    >   - 피호출자 저장(callee-saved) 레지스터(%rbx, %rbp, %r12–%r15)는 피호출 함수가 값을 보존
    >     - 자기가 레지스터 쓰면 데이터가 덮어씌워지니까 돌려줄 때 대비해서 미리 저장해 두는것
    > 
    >   - 호출자 저장(caller-saved) 레지스터는 호출 함수가 필요 시 직접 저장


    > 지역 변수 저장:
    >
    > - 레지스터 개수가 부족할 때
    > - 지역 변수에 주소 연산자(`&`)를 사용하여 주소를 알아내야 할 때.
    > - 지역 변수가 배열이나 구조체일 때.




* **스택 프레임 해제:**

  프로시저가 반환될 때, 스택 포인터를 원래 위치로 복원(예: `addq $16, %rsp`)함으로써
  할당했던 스택 프레임을 간단하게 해제




## 고급 요소:  고급 데이터 구조


_이제까지 배운 지식을 총동원하여
배열, 구조체와 같은 복합 데이터 타입과 부동소수점 연산이 기계 수준에서 어떻게 처리되는지 살펴봅니다._


목표:

  - C의 포인터가 실제로는 메모리 주소이며, 배열 접근(`a[i]`)과 포인터 연산(`*(a+i)`)이
    기계 수준에서는 동일한 주소 계산으로 구현된다는 것을 명확히 이해


### Array Allocation and Access


#### Basic Principles


- 기계 수준에서 두 가지 단순한 원칙에 따라 구현

  - 배열의 할당: 지정한 타입에 해당하는 크기를 연속적으로 할당
  - 배열의 주소: 배열의 이름을 할당된 메모리 블록의 포인터로 사용


- 배열 요소 접근: 기본원칙에 따라 역시 단순함

  - 주소계산: 배열의 시작점 주소에 index(순서) * 데이터의 크기
    - 즉 배열의 접근을 위한 연산은 포인터 연산임


> [!nt] 통찰
>
> - 설명처럼 기계수준에서 배열은 단순한 바이트의 나열이다. 그래서 경계검사를 하지 않는다.
>   그러니까 overflow 문제가 발생할 여지가 있는 부분이다.
>   - 경계검사: 배열의 길이를 벗어난 영역에 접근하는지 검사(통칭 out-of-bound)
>
> - 반복문 내 접근 등에서 (상대적)고비용의 주소계산을 하기보다 단순히 pointer 연산을 통해
>   최적화(컴파일러)
>
> - 다차원 배열에서 행 우선 순서를 이용해 성능을 향상시킬 수 있다. RAM보다 빠른 캐시메모리에는
>   연속된 바이트가 같이 캐싱되 기때문이다.



#### Pointer Arithmetic

- 주소값을 가져오는 인스트럭션은 `leaq`

  - `leaq` == `lea + q`
    - `lea`는 Load Effective Address
    - `q`는 64b 크기인 포인터를 다루는 연산이란것

- 배열 요소에 접근하는 주소 == `시작 주소 + (요소 크기 * i)`



> [!qt] 근데 어차피 덧셈 곱셈 할꺼면 그냥 add, imul같은거 해서 똑같은거 아니냐? 
>
>   󱞪 아니다. 기계적 층위에서 보면  `add`, `imul`같은 산술 연산과는 다름
>
>   > - **일반산술연산:**
>   > 
>   >   - 계산비용이 큼:
>   >     `ALU`에서 연산. 따라서 어떤 레지스터와 다른 레지스터에서 값을 복사해오고 연산 후 다시
>   >     복사해 넣어야한다. 아주 여러번의 연산을 요구함
>   > 
>   >   - Flag 레지스터에 영향을 줌:
>   >     이 연산들은 조건코드(codition code)를 변경하는 side effect가 있다. 주소를 얻기위해
>   >     플래그를 오염시키면 이것을 복원하는 연산비용도 추가되었을 것.
>   > 
>   > 
>   > - **주소연산:**
>   > 
>   >   - `Address Generation Unit(AGU)` 라는 특화된 회로에서 **단 1클럭으로 계산**
>   >   - 또한 조건 코드를 변경하는 side effect가 없음
>
>
> - 이런 이점 덕분에 컴파일러는 주소연산 외에도 이 명령을 활용한다.



#### Nested Arrays

- 똑같이 연속적인 바이트의 나일이기 때문에 똑같이 주소계산 하면 그만이다.

#### Fixed-Size Arrays

- 고정크기 배열에선 컴파일러가 바이트의 나열이라는 단순한 원칙을 이용해 매우 효과적으로
  최적화한다.

  - 예를들어 반복문 내에서 2차원 배열의 특정 값 두 개의 연산을 수행하려면 주소값을 얻기 위해
    매 반복마다 인덱스 및 배열 원소의 개수를 곱해야한다.

    그런데 컴파일러는 배열에 담긴 원소의 크기를 통해 이것을 단순한 덧셈으로 포인터를 이동시킨다.

  - 또한 루프 종료도 저렴한 비용의 포인터 계산을 통해 단순 값 비교로 효과적으로 해낸다.


> [!qt] 덧셈과 곱셈의 비용이 그렇게 차이가 큰가?
>   󱞪  그렇다.
>
>   덧셈은 그냥 덧셈이라면,
>   곱셈은 각 자리의 숫자들로 곱한 뒤 그결과를 모두 더해야 한다.
>
>   현대의 x86-64에서 덧셈은 약 1 clock, 곱셈은 3~4 clock


#### Variable-Size Arrays

- 주소값을 완전히 미리 얻을 수 없기 때문에 고정 크기 배열만큼의 최적화는 안된다.

- 하지만 반복문 내의 사용 등 여전히 바이트의 나열이라는 원리를 이용할 수 있는 경우 최적화를
  시도한다.


### Heterogeneous Data Structures


_- 이종데이터는 구조체(structure)와 공용체(union)를 말함_
_- 이것도 결국 기계어 수준에서 어떤식의 바이트 나열로 인코딩 되는지를 아는 것이 중요함_



- 데이터 추상화의 제거:

  컴파일러는 C언어의 추상적 개념을 기계가 이해할 수 있는 구체적 요소로 변환한다. 오직 Byte
  Offset과 크기에 대한 정보만 기계 코드에 남게 된다.

- 데이터 정렬을 통해 메모리 시스템의 성능을 최적화


#### Structures


- 저장(메모리에 표현)
  - 여러 타입의 필드들을 메모리상에 연속적으로 할당하여 하나의 객체로 묶음
  - 각 필드는 구조체의 시작 주소로부터 고유한 바이트 오프셋을 가짐

- 접근
  - 베이스 주소(구조체 포인터)에 고정된 offset을 더하는 메모리 참조
  - `movl %eax, 4(%rdi)` 처럼 %rdi 레지스트에 저장된 베이스주소로부터 offset 4바이트만큼 
    더한 위치

- 컴파일러의 최적화
  - 각 원소가 int는 4B, long은 8B 처럼 각 필드에 타입에 딱 맞는 크기가 되도록 padding
  - 이 때문에 프로그래머가 코드에 표현한 것보다 기계수준에선 더 큰 메모리를 차지할 수 있음




#### Unions


- 저장(메모리에 표현)

  - union은 struct와 달리 모든 필드가 동일한 메모리 블록을 공유

  - 전체 크기는 가장 큰 필드의 크기에 맞춰 결정

  - C언어의 타입 시스템을 우회하여 하나의 비트 패턴을 여러 다른 데이터 타입으로 해석할 수 있게
    해주는 강력하지만 위험한 기능




- 특징

  - 공간 효율성이 좋음

  - 명시적 태그 필요: 현재 어떤 필드가 유효한지 프로그래머가 직접 관리해야함. 따라서 enum 같은
    태그 필드를 공용체 안에 포함



#### Data Alignment



_- 메모리 레이아웃은 변경될 수 있으며, 컴파일러가 결정한다._
_- 실제 메모리를 얼만큼 사용하는지는 예측이 어렵다._
_- x86-64 아키텍처는 데이터가 정렬되지 않아도 올바르게 동작하지만, 정렬된 데이터에 접근할 때
  메모리 시스템의 성능이 크게 향상_




- **정렬 규칙**

  - _K 바이트 크기의 데이터 타입은 주소가 반드시 K의 배수여야 한다_
  - 예를 들어, `short`(2B)는 2의 배수 주소에, `int`(4B)는 4의 배수 주소

  - 구조체는 모든 필드가 각각의 정렬 요구사항을 만족하도록 보장해야함
    - 데이터 타입에 비해 작은 값이 들어있는 경우 padding을 삽입해줌
    - 통상 `0x00`인데, C언어 표준의 내용은 아님


    - 구조체 내부 패딩
    
      각 필드의 offset은 데이터타입의 배수여야한다.

      ex) `struct S1 { int i; char c; int j; };`라면 `4 + 1 + 4`가 되는데, `i`, `c`는 각각
          정렬되었지만 `j`는 offset이 5가돼서 int타입의 크기의 배수가 아니다. 따라서
          컴파일러는 다음과같이 인코딩한다. => `4 + 1 + 3(padding) + 4`


    - 구조체 전체 정렬 및 끝 패딩

      _구조체 내부 패딩보다 더 엄격한 정렬규칙이다._

      위의 예시와 같은 구조체를 배열로 만든다면, 그 구조체 자체도 정렬 요구사항을 만족해야한다.
      그래서 해당 구조체 내부의 가장 큰 데이터 타입인 int의 4B의 배수가 되어야 하지만, 시작
      주소가 4의 배수였더라도 이어지는 2번째 원소는 4의 배수가 못된다.

      그래서 컴파일러는 구조체 끝에 3B를 추가(padding)하여 개별 원소를 총 12B로 만든다.



- **성능상의 이점**

  - 프로세서는 메모리에서 데이터를 8바이트나 16바이트 같은 블록 단위로 읽어옴

  - 만약 8바이트 `double` 데이터가 8의 배수 주소에 정렬되어 있다면, 단 한 번의 메모리
    작업으로 값을 가져올 수 있다. 하지만 정렬되지 않아 두 개의 8바이트 메모리 블록에 걸쳐
    있다면, 프로세서는 두 번의 메모리 접근을 수행해야 하므로 성능이 저하된다.



## 응용     :  보안 및 특수 연산

    
### Combining Control and Data

(포인터에 대한 깊은 이해를 바탕으로)

- 배열의 경계를 벗어난 쓰기(out-of-bounds write)가 어떻게 버퍼 오버플로우(buffer overflow)
  공격으로 이어지는지 구체적으로 분석

- 방어하기 위한 최신 기술들: 스택 랜덤화, 스택 보호 기법(카나리 값) 등



### Floating-Point Code

- 정수 연산과는 다른 별도의 레지스터(XMM/YMM)와 명령어 집합을 사용하는 부동소수점 연산이 어떻게 처리되는지

